<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIPschell: Yield management</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIPschell
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
   <div id="projectbrief">A language for writing Mixed Integer Programs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Yield management </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="mipshell_yieldManagement"></a>
Yield management</h1>
<p><em>Yield</em> (<em>revenue</em>) management_ is an approach to revenue maximization for service firms that exhibit the following characteristics:</p>
<ul>
<li>1. <em>Relatively fixed capacity</em>. Service firms with substantial investment in facilities (e.g., hotels and airlines) are capacity-constrained (once all the seats on a flight are sold, further demand can be met only by booking passengers on a later flight).</li>
<li>2. <em>Ability to segment its market</em> into different customer classes. Developing various price-sensitive classes of service gives firms more flexibility in different seasons of the year.</li>
<li>3. <em>Perishable inventory</em>. Revenue from an unsold seat in a plane or from unsold room in a hotel is lost forever.</li>
<li>4. <em>Reservation</em> systems are adopted by service firms to sell capacity in advance of use. However, managers are faced with uncertainty of whether to accept an early reservation at a discount price or to wait in hope to sell later seats or rooms to higher-paying customers.</li>
<li>5. <em>Fluctuating demand</em>. To sell more seats or rooms and increase revenue, in periods of slow demand managers can lower prices, while in periods of high demands prices are getting higher.</li>
</ul>
<h2><a class="anchor" id="mipshell_yieldInAirline"></a>
Revenue Management In Airline Industry</h2>
<p>Now let us turn to setting of a concrete problem. An airline starts selling tickets for flights to a particular destination <em>D</em> days before the departure. The time horizon of <em>D</em> days are divided into <em>T</em> periods of unequal length (for example, a time horizon of <em>D</em>=60 days can be divided into <em>T</em>=4 periods of length 30, 20, 7 and 3 days). It can be used up to <img class="formulaInl" alt="$s_k$" src="form_160.png"/> planes of type <em>k</em> each costing <img class="formulaInl" alt="$f_k$" src="form_161.png"/> to hire, <em>k</em>=1,...,<em>K</em>. Each plane of type <em>k</em> has</p><ul>
<li><img class="formulaInl" alt="$q_{1k}$" src="form_162.png"/> first class seats (referred to as class&#160;1 in the following),</li>
<li><img class="formulaInl" alt="$q_{2k}$" src="form_163.png"/> business class seats (class&#160;2),</li>
<li>and <img class="formulaInl" alt="$q_{3k}$" src="form_164.png"/> economy class seats (class&#160;3.</li>
</ul>
<p>Up to <img class="formulaInl" alt="$r_i$" src="form_165.png"/> percent of seats of class&#160;<em>i</em> can be transformed into seats of adjacent categories, <em>i</em>=1,2,3.</p>
<p>For administrative simplicity, in each period&#160;<em>t</em> (<em>t</em>=1,...,<em>T</em>) only <em>O</em> price options can be used, and let <img class="formulaInl" alt="$c_{tio}$" src="form_166.png"/> denote the price of a seat of class&#160;<em>i</em> (<em>i</em>=1,2,3) in period <em>t</em> if option <em>o</em> is used.</p>
<p>Demand is uncertain but is affected by price. Let us assume that <em>S</em> scenarios are possible in each period. Forecasts have been made for these demands for each scenario in each of <em>T</em> periods. The probability of scenario <em>s</em> (<em>s</em>=1,...,<em>S</em>) in period <em>T</em> is <img class="formulaInl" alt="$p_{ts}$" src="form_167.png"/>, <img class="formulaInl" alt="$\sum_{s=1}^{S} p_{ts} = 1$" src="form_168.png"/>. If scenario <em>s</em> happens in period <em>t</em>, and price option <em>o</em> is used in this period, then the demand for seats of class&#160;<em>i</em> will be <img class="formulaInl" alt="$d_{tsio}$" src="form_169.png"/>.</p>
<p>We have to decide how many planes of each type to hire, and, for each of <em>T</em> periods, and for each of price levels, how many seats to sell in each class (depending on demand) to maximize expected yield.</p>
<h2><a class="anchor" id="mipshell_YieldExample"></a>
Example</h2>
<p>An airline is selling tickets for flights to a particular destination. The flight will depart in three weeks' time. Up to six planes can be hired. Each plane costs $75000 to hire, and has</p><ul>
<li>35 first class seats,</li>
<li>40 business class seats,</li>
<li>60 economy class seats.</li>
</ul>
<p>Up to 10% of seats in any one category can be transferred to an adjacent category.</p>
<p>An airline wishes to decide a price for each of these seats. There will be further opportunities to update these prices in after one week and two weeks. Once a customer has purchased a ticket there is no cancellation option.</p>
<p>For administrative simplicity three price level options are possible in each class (one of which must be chosen). These options are given in Table&#160;1 for the current period (Perion&#160;1) and two future periods.</p>
<center> <a class="anchor" id=""></a>
<table class="doxtable">
<caption>Table&#160;1: <em>Price Options</em></caption>
<tr>
<th></th><th>Class </th><th>Option&#160;1 </th><th>Option&#160;2 </th><th>Option&#160;3  </th></tr>
<tr>
<th></th><th>First </th><td>$1500 </td><td>$1250 </td><td>$1000  </td></tr>
<tr>
<th>Period 1 </th><th>Busines </th><td>$1000 </td><td>$850 </td><td>$700  </td></tr>
<tr>
<th></th><th>Economy </th><td>$500 </td><td>$400 </td><td>$300  </td></tr>
<tr>
<th></th><th>First </th><td>$1750 </td><td>$1500 </td><td>$1250  </td></tr>
<tr>
<th>Period 2 </th><th>Busines </th><td>$1250 </td><td>$1000 </td><td>$850  </td></tr>
<tr>
<th></th><th>Economy </th><td>$700 </td><td>$500 </td><td>$400  </td></tr>
<tr>
<th></th><th>First </th><td>$1800 </td><td>$1200 </td><td>$900  </td></tr>
<tr>
<th>Period 3 </th><th>Busines </th><td>$800 </td><td>$850 </td><td>$600  </td></tr>
<tr>
<th></th><th>Economy </th><td>$450 </td><td>$500 </td><td>$450  </td></tr>
</table>
</center><p>Demand is uncertain and is affected by ticket prices. Forecasts have been made, and demand levels have been divided into three scenarios for each period. The probabilities of these scenarios in each period are: </p><center> <table class="doxtable">
<tr>
<th>Scenario 1 </th><td>0.1  </td></tr>
<tr>
<th>Scenario 2 </th><td>0.6  </td></tr>
<tr>
<th>Scenario 3 </th><td>0.3  </td></tr>
</table>
</center><p>The forecast demands are shown in tables&#160;2&ndash;4.</p>
<center> <a class="anchor" id=""></a>
<table class="doxtable">
<caption>Table&#160;2: <em>Forecast Demands for Scenario 1</em></caption>
<tr>
<th></th><th>Class </th><th>Option&#160;1 </th><th>Option&#160;2 </th><th>Option&#160;3  </th></tr>
<tr>
<th></th><th>First </th><td>25 </td><td>30 </td><td>35  </td></tr>
<tr>
<th>Period 1 </th><th>Busines </th><td>40 </td><td>50 </td><td>70  </td></tr>
<tr>
<th></th><th>Economy </th><td>100 </td><td>120 </td><td>130  </td></tr>
<tr>
<th></th><th>First </th><td>40 </td><td>50 </td><td>65  </td></tr>
<tr>
<th>Period 2 </th><th>Busines </th><td>85 </td><td>90 </td><td>85  </td></tr>
<tr>
<th></th><th>Economy </th><td>100 </td><td>105 </td><td>125  </td></tr>
<tr>
<th></th><th>First </th><td>60 </td><td>70 </td><td>80  </td></tr>
<tr>
<th>Period 3 </th><th>Busines </th><td>80 </td><td>100 </td><td>110  </td></tr>
<tr>
<th></th><th>Economy </th><td>100 </td><td>120 </td><td>160  </td></tr>
</table>
</center><p> <br />
 </p><center> <a class="anchor" id=""></a>
<table class="doxtable">
<caption>Table&#160;3: <em>Forecast Demands for Scenario 2</em></caption>
<tr>
<th></th><th>Class </th><th>Option&#160;1 </th><th>Option&#160;2 </th><th>Option&#160;3  </th></tr>
<tr>
<th></th><th>First </th><td>40 </td><td>50 </td><td>70  </td></tr>
<tr>
<th>Period 1 </th><th>Busines </th><td>90 </td><td>85 </td><td>90  </td></tr>
<tr>
<th></th><th>Economy </th><td>100 </td><td>105 </td><td>140  </td></tr>
<tr>
<th></th><th>First </th><td>20 </td><td>80 </td><td>100  </td></tr>
<tr>
<th>Period 2 </th><th>Busines </th><td>100 </td><td>120 </td><td>160  </td></tr>
<tr>
<th></th><th>Economy </th><td>120 </td><td>130 </td><td>180  </td></tr>
<tr>
<th></th><th>First </th><td>60 </td><td>80 </td><td>120  </td></tr>
<tr>
<th>Period 3 </th><th>Busines </th><td>20 </td><td>80 </td><td>90  </td></tr>
<tr>
<th></th><th>Economy </th><td>100 </td><td>120 </td><td>140  </td></tr>
</table>
</center><p> <br />
 </p><center> <a class="anchor" id=""></a>
<table class="doxtable">
<caption>Table&#160;4: <em>Forecast Demands for Scenario 3</em></caption>
<tr>
<th></th><th>Class </th><th>Option&#160;1 </th><th>Option&#160;2 </th><th>Option&#160;3  </th></tr>
<tr>
<th></th><th>First </th><td>90 </td><td>100 </td><td>120  </td></tr>
<tr>
<th>Period 1 </th><th>Busines </th><td>90 </td><td>95 </td><td>95  </td></tr>
<tr>
<th></th><th>Economy </th><td>110 </td><td>105 </td><td>135  </td></tr>
<tr>
<th></th><th>First </th><td>100 </td><td>110 </td><td>160  </td></tr>
<tr>
<th>Period 2 </th><th>Busines </th><td>40 </td><td>60 </td><td>100  </td></tr>
<tr>
<th></th><th>Economy </th><td>25 </td><td>80 </td><td>120  </td></tr>
<tr>
<th></th><th>First </th><td>100 </td><td>140 </td><td>160  </td></tr>
<tr>
<th>Period 3 </th><th>Busines </th><td>80 </td><td>90 </td><td>120  </td></tr>
<tr>
<th></th><th>Economy </th><td>120 </td><td>130 </td><td>140  </td></tr>
</table>
</center><h2><a class="anchor" id="mipshell_MIPforYield"></a>
Integer Programming Formulation</h2>
<p>To write a deterministic model for this stochastic problem, we need to describe a scenario tree. In this application the scenario tree has <img class="formulaInl" alt="$n+1=\sum_{t=0}^{T} S^t$" src="form_170.png"/> nodes. Let us denote by <img class="formulaInl" alt="$V_t$" src="form_171.png"/> the set of <img class="formulaInl" alt="$S^t$" src="form_172.png"/> nodes in level&#160;<em>t, _t</em>=0,1,...,<em>T</em>. Let us also assume that the root of the scenario tree is indexed by 0, and then <img class="formulaInl" alt="$V_0=\{0\}$" src="form_173.png"/>.</p>
<p>Each node <img class="formulaInl" alt="$j\in V_t$" src="form_174.png"/> (<em>t</em>=1,...,<em>T</em>) corresponds to one of the situations that may happen after <em>t</em> periods, and is characterized by a sequence of integers <img class="formulaInl" alt="$(s_1,s_2,\dots,s_t)$" src="form_175.png"/>, where <img class="formulaInl" alt="$s_{\tau}\in \{1,\dots,S_{\tau}\}$" src="form_176.png"/> is an index of a scenario for period&#160; <img class="formulaInl" alt="$\tau$" src="form_177.png"/>. The situation of node&#160; <img class="formulaInl" alt="$j\in V_t$" src="form_174.png"/> happens with probability <img class="formulaInl" alt="$\bar{p}_j\stackrel{\mathrm{def}}{=} \prod_{\tau=1}^t p_{\tau,s_{\tau}}$" src="form_178.png"/> and, if price option&#160;<em>o</em> is used, the demand for seats of class&#160;<em>i</em> is <img class="formulaInl" alt="$\bar{d}_{jio}\stackrel{\mathrm{def}}{=} d_{t,s_t,i,o}$" src="form_179.png"/>, and their price is <img class="formulaInl" alt="$c_{tio}$" src="form_166.png"/>. Let us define <img class="formulaInl" alt="$\bar{c}_{jio}\stackrel{\mathrm{def}}{=} \bar{p}_j c_{tio}$" src="form_180.png"/>. The parent of node&#160;<em>j</em>, denoted by <img class="formulaInl" alt="$parent(j)$" src="form_181.png"/>, is that node in <img class="formulaInl" alt="$V_{t-1}$" src="form_182.png"/> which is characterized by the sequence <img class="formulaInl" alt="$(s_1,s_2,\dots,s_{t-1})$" src="form_183.png"/>. Note, that the root node <em>0</em> is the parent of all nodes in <img class="formulaInl" alt="$V_1$" src="form_184.png"/> (of level&#160;1).</p>
<h3><a class="anchor" id="Variables"></a>
Variables</h3>
<p>Let <img class="formulaInl" alt="$v_k$" src="form_185.png"/> denote the number of planes of type <em>k</em> used. With each node <img class="formulaInl" alt="$j\in V\setminus V_T$" src="form_186.png"/> we associate the following variables:</p><ul>
<li><img class="formulaInl" alt="$x_{jio}$" src="form_187.png"/>: number of seats of class&#160;<em>i</em> to be sold in period&#160;<em>t</em> using price option&#160;<em>o</em>, when situation of node&#160;<em>j</em> happens;</li>
<li><img class="formulaInl" alt="$y_{jio}=1$" src="form_188.png"/> if price option&#160;<em>o</em> is used for class&#160;<em>i</em> when situation of node&#160;<em>j</em> happens, and <img class="formulaInl" alt="$y_{jio}=0$" src="form_189.png"/> otherwise.</li>
</ul>
<p>Each node <img class="formulaInl" alt="$j\in V$" src="form_190.png"/> is associated with the variables:</p><ul>
<li><img class="formulaInl" alt="$z_{ji}$" src="form_191.png"/>: number of seats of class&#160;<em>i</em> to be sold until situation of node&#160;<em>j</em> happens.</li>
</ul>
<p>Now we can write the following integer program: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} -\sum_{k=1}^K f_k v_k &amp;+ \sum_{j\in V\setminus V_T} \sum_{o=1}^{O} \sum_{i=1}^3 \bar{c}_{jio} x_{jio} \to \max, \tag{1.a}\\ \sum_{o=1}^{O} &amp;y_{jio} = 1,\quad j\in V\setminus V_T,\; i=1,2,3,\tag{1.b}\\ x_{jio} &amp;\le \bar{d}_{jio} y_{jio},\quad j\in V\setminus V_T,\; i=1,2,3,\; o=1,\dots,O, \tag{1.c}\\ z_{ji} &amp;= z_{parent(j),i} + \sum_{o=1}^{O} x_{parent(j),i,o}\,,\quad j\in V\setminus \{0\},\; i=1,2,3, \tag{1.d}\\ z_{j1} &amp;\le \sum_{k=1}^K (q_{1k} + \lfloor r_{2k} q_{2k}/100\rfloor)\, v_k,\quad j\in V_T,\tag{1.e}\\ z_{j2} &amp;\le \sum_{k=1}^K (q_{2k} + \lfloor (r_{1k} q_{1k} + r_{3k} q_{3k})/100\rfloor)\, v_k,\quad j\in V_T,\tag{1.f}\\ z_{j3} &amp;\le \sum_{k=1}^K (q_{3k} + \lfloor r_{2k} q_{2k}/100\rfloor)\, v_k,\quad j\in V_T,\tag{1.g}\\ z_{j1} &amp;+ z_{j3} \le \sum_{k=1}^K (q_{1k}+q_{3k} + \lfloor r_{2k} q_{2k}/100\rfloor)\, v_k,\quad j\in V_T,\tag{1.h}\\ z_{j1} &amp;+ z_{j2} + z_{j3} \le \sum_{k=1}^K (q_{1k}+q_{2k} + q_{3k})\, v_k,\quad j\in V_T,\tag{1.i}\\ x_{jio} &amp;\in \mathbb{Z}_+,\quad j\in V\setminus V_T,\; i=1,2,3,\; o=1,\dots, O,\tag{1.j}\\ y_{jio} &amp;\in \{0,1\},\quad j\in V\setminus V_T,\; i=1,2,3,\; o=1,\dots, O,\tag{1.k}\\ z_{ji} &amp;\in \mathbb{Z}_+,\quad j\in V,\; i=1,2,3,\tag{1.l}\\ z_{0i} &amp;= 0,\quad i=1,2,3,\tag{1.m}\\ v_k &amp;\in\mathbb{Z}_+\,,\; v_k \le s_k,\quad k=1,\dots,K.\tag{1.n} \end{align}" src="form_192.png"/>
</p>
<p>The objective (1.a) is to maximize the profit from selling seets minus the expenses for hiring planes. The equations (1.b) are to guarantee that in any of <em>T</em> periods only one price option is chosen for each class. The variable upper bounds (1.c) guarantee that in any period and for any price option, the number of seats sold for each of three classes does not exceed the demand for these seats. The balance equations (1.d) count the total number of seats for each of the classes that are sold in any of <em>T</em> periods. The inequalities (1.e)&ndash;(1.i) require that the total number of seats sold be no more that the number of seats in all the planes hired by the airline.</p>
<p>When the problem (1) is sold, we know which options to use and how many seats of each class to be sold in period~1 (this is determined by the values of variables <img class="formulaInl" alt="$x_{0io}$" src="form_193.png"/>). When period&#160;1 is over, we will know the actual number of seats of each class sold in this period, and we will write down a new model for periods 2,...,<em>T</em> to determine optimal price option and number of seats of each class to be sold in Period&#160;2. This procedure is then repeated for periods <em>t</em>=3,...,<em>T</em>.</p>
<h2><a class="anchor" id="mipshell_YieldImpl"></a>
MIPshell Implementation</h2>
<p>To implement IP (1), we developed a <b>C++</b> class named <code>Cyield</code> which definition is as follows.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mipshell_8h.html">mipshell.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>sPlane {</div><div class="line">    <span class="keywordtype">int</span> num; </div><div class="line">    <span class="keywordtype">double</span> cost; </div><div class="line">    <span class="keywordtype">int</span> q1, q2, q3, </div><div class="line">        r1, r2, r3;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>sNode {</div><div class="line">    <span class="keywordtype">int</span> ind, parent,</div><div class="line">        period; </div><div class="line">    <span class="keywordtype">double</span> prob;</div><div class="line">    <span class="keywordtype">int</span> *demand; </div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">class </span>Cyield: <span class="keyword">public</span> <a class="code" href="classCProblem.html">CProblem</a></div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> m_iT; </div><div class="line">    <span class="keywordtype">int</span> m_iPlaneTypeNum; </div><div class="line">    sPlane *m_pPlane; </div><div class="line">    <span class="keywordtype">int</span> m_iOptNum; </div><div class="line">    <span class="keywordtype">double</span> *m_dpCost; </div><div class="line">    <span class="keywordtype">int</span> m_iNodeNum, m_iLeafNum; </div><div class="line">    sNode *m_pNode; </div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Cyield(<span class="keyword">const</span> <span class="keywordtype">char</span>* name);</div><div class="line"><span class="preprocessor">#ifdef __THREADS_</span></div><div class="line">    Cyield(<span class="keyword">const</span> Cyield &amp;other, <span class="keywordtype">int</span> thread);</div><div class="line">    <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a>* clone(<span class="keyword">const</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    <span class="keyword">virtual</span> ~Cyield();</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> model();</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> readParameters();</div><div class="line">    <span class="keywordtype">void</span> readOptions();</div><div class="line">    <span class="keywordtype">void</span> readTree();</div><div class="line">    <span class="keywordtype">void</span> readData(<span class="keyword">const</span> <span class="keywordtype">char</span> *name);</div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p>First, let us consider data structures used to represent problem instances.</p>
<p><code>sPlane</code> describes planes of a particular type. Its members are:</p><ul>
<li><code>num</code>: number of planes of this type;</li>
<li><code>cost</code>: cost to hire;</li>
<li><code>q1</code>, <code>q2</code>, <code>q3</code>: number of seats of first, business and economy classes;</li>
<li><code>r1</code>, <code>r2</code>, <code>r3</code>: percent of seats of first, business and economy classes that can be transformed into seats of adjacent classes.</li>
</ul>
<p><code>sNode</code> represents scenario tree nodes. Its memmbers are:</p><ul>
<li><code>ind</code>: node index;</li>
<li><code>parent</code>: parent node index;</li>
<li><code>period</code>: node level, <code>m_pNode[ind].period = m_pNode[parent].period+1</code>;</li>
<li><code>prob</code>: probability that situation described by this node will happen;</li>
<li><code>demand</code>: array of price options of size <code>3*m_iOptNum</code>, where <code>demand[3*o+i]</code> is demand for tickets of type <code>i</code> if price option <code>o</code> is used.</li>
</ul>
<p>Now we describe all members of <code>Cyild</code>:</p><ul>
<li><code>m_iT</code>: number of periods;</li>
<li><code>m_iPlaneTypeNum</code>: number of types of planes;</li>
<li><code>m_pPlane</code>: array of size <code>m_iPlaneTypeNum</code>, where <code>m_pPlane[k]</code> describes plane of type <code>k</code>;</li>
<li><code>m_iOptNum</code>: number of options at any period;</li>
<li><code>m_dpCost</code>: array of size <code>3*m_iT*m_iOptNum</code>, where <code>m_dpCost[(t*3+o)*m_iOptNum+i]</code> is cost of class <code>i</code> ticket if option <code>o</code> is used in period <code>t</code>;</li>
<li><code>m_iNodeNum</code>, <code>m_iLeafNum</code>: number of nodes and leaves in scenario tree;</li>
<li><code>m_pNode</code>: array of nodes (of size <code>m_iNodeNum</code>) of scenario tree.</li>
</ul>
<p>Next, we discuss the implementation of the constructors and the destructor of <code>Cyild</code>. The default constructor of <code>Cyield</code></p>
<p><div class="fragment"><div class="line">Cyield::Cyield(<span class="keyword">const</span> <span class="keywordtype">char</span>* name): <a class="code" href="classCProblem.html">CProblem</a>(name)</div><div class="line">{</div><div class="line">    m_pNode=0;</div><div class="line">    m_pPlane=0;</div><div class="line">    m_dpCost=0;</div><div class="line">    readData(name);</div><div class="line">}</div></div><!-- fragment --></p>
<p>gets as its input parameter, <code>name</code>, the name of a directory with three text files, <code>param.txt</code>, <code>options.txt</code>, and <code>tree.txt</code>, describing a problem instanse. This constructor just calls the function <code>readData()</code> to read a problem instance from the files in <code>name</code>.</p>
<p>The implementation of the copy and clone constructors is as follows.</p>
<p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef __THREADS_</span></div><div class="line">Cyield::Cyield(<span class="keyword">const</span> Cyield &amp;other, <span class="keywordtype">int</span> thread): <a class="code" href="classCProblem.html">CProblem</a>(other,thread)</div><div class="line">{</div><div class="line">    m_iT=other.m_iT;</div><div class="line">    m_iPlaneTypeNum=other.m_iPlaneTypeNum;</div><div class="line">    m_pPlane=other.m_pPlane;</div><div class="line">    m_iNodeNum=other.m_iNodeNum;</div><div class="line">    m_iLeafNum=other.m_iLeafNum;</div><div class="line">    m_pNode=other.m_pNode;</div><div class="line">    m_iOptNum=other.m_iOptNum;</div><div class="line">    m_dpCost=other.m_dpCost;</div><div class="line">} <span class="comment">// end of Cyield::Cyield(Cyield &amp;other, int thread)</span></div><div class="line"></div><div class="line"><a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a>* Cyield::clone(<span class="keyword">const</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a>*<span class="keyword">&gt;</span>(<span class="keyword">new</span> Cyield(*static_cast&lt;Cyield*&gt;(const_cast&lt;CMIP*&gt;(pMip)),thread));</div><div class="line">}</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --></p>
<p>The copy constructor just initializes the members of the newly created <code>Cyield</code> object with the members of the object to be copied.</p>
<p>The destructor frees the memory allocated for the scenario tree as well as for two arrays <code>m_pPlane</code> and <code>m_dpCost</code>.</p>
<p><div class="fragment"><div class="line">Cyield::~Cyield()</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifdef __THREADS_</span></div><div class="line">    <span class="keywordflow">if</span> (!m_iThread) {</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="keywordflow">if</span> (m_pNode) {</div><div class="line">            sNode *pNode=m_pNode;</div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i &lt; m_iNodeNum; ++i, ++pNode) {</div><div class="line">                <span class="keyword">delete</span>[] pNode-&gt;demand;</div><div class="line">            }</div><div class="line">            <span class="keyword">delete</span>[] m_pNode;</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (m_pPlane)</div><div class="line">            <span class="keyword">delete</span>[] m_pPlane;</div><div class="line">        <span class="keywordflow">if</span> (m_dpCost)</div><div class="line">            <span class="keyword">delete</span>[] m_dpCost;</div><div class="line"><span class="preprocessor">#ifdef __THREADS_</span></div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">} // end of Cyield::~Cyield()</span></div></div><!-- fragment --></p>
<p><code>readData()</code> calls <code>readParameters()</code>, <code>readOptions()</code>, <code>readTree()</code> to read data from, respectively, <code>param.txt</code>, <code>options.txt</code>, and <code>tree.txt</code>.</p>
<p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Cyield::readParameters()</div><div class="line">{</div><div class="line">    std::ifstream fin(<span class="stringliteral">&quot;param.txt&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (!fin.is_open()) {</div><div class="line">        <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCFileException.html">CFileException</a>(<span class="stringliteral">&quot;Cyild::ReadParameters&quot;</span>,<span class="stringliteral">&quot;param.txt&quot;</span>);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordtype">int</span> n;</div><div class="line">    fin &gt;&gt; m_iT &gt;&gt; n;</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!(m_pPlane = <span class="keyword">new</span>(std::nothrow) sPlane[m_iPlaneTypeNum=n])) {</div><div class="line">        <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMemoryException.html">CMemoryException</a>(<span class="stringliteral">&quot;Cyild::ReadParameters&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    sPlane *plane=m_pPlane;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0; k &lt; n; ++k, ++plane) {</div><div class="line">        fin &gt;&gt; plane-&gt;num &gt;&gt; plane-&gt;cost</div><div class="line">            &gt;&gt; plane-&gt;q1 &gt;&gt; plane-&gt;r1</div><div class="line">            &gt;&gt; plane-&gt;q2 &gt;&gt; plane-&gt;r2</div><div class="line">            &gt;&gt; plane-&gt;q3 &gt;&gt; plane-&gt;r3;</div><div class="line">    }</div><div class="line">    fin.close();</div><div class="line">} <span class="comment">// end of Cyield::readParameters()</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Cyield::readOptions()</div><div class="line">{</div><div class="line">    std::ifstream fin(<span class="stringliteral">&quot;options.txt&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (!fin.is_open()) {</div><div class="line">        <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCFileException.html">CFileException</a>(<span class="stringliteral">&quot;Cyild::ReadOptions&quot;</span>,<span class="stringliteral">&quot;options.txt&quot;</span>);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordtype">int</span> m;</div><div class="line">    <span class="keywordtype">double</span> *cost;</div><div class="line">    fin &gt;&gt; m;</div><div class="line">    m_iOptNum=m;</div><div class="line">    <span class="keywordflow">if</span> (!(m_dpCost=cost=<span class="keyword">new</span>(std::nothrow) <span class="keywordtype">double</span>[3*m*m_iT])) {</div><div class="line">        fin.close();</div><div class="line">        <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMemoryException.html">CMemoryException</a>(<span class="stringliteral">&quot;Cyild::ReadOptions&quot;</span>);</div><div class="line">    }</div><div class="line"></div><div class="line">    m*=(3*m_iT);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; m; ++i) {</div><div class="line">        fin &gt;&gt; cost[i];</div><div class="line">    }</div><div class="line">    </div><div class="line">    fin.close();</div><div class="line">} <span class="comment">// end of Cyield::readOptions()</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Cyield::readTree()</div><div class="line">{</div><div class="line">    std::ifstream fin(<span class="stringliteral">&quot;tree.txt&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (!fin.is_open()) {</div><div class="line">        <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCFileException.html">CFileException</a>(<span class="stringliteral">&quot;Cyild::ReadTree&quot;</span>,<span class="stringliteral">&quot;tree.txt&quot;</span>);</div><div class="line">    }</div><div class="line">    fin &gt;&gt; m_iNodeNum;</div><div class="line">    <span class="keywordflow">if</span> (!(m_pNode = <span class="keyword">new</span>(std::nothrow) sNode[++m_iNodeNum])) {</div><div class="line">        <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMemoryException.html">CMemoryException</a>(<span class="stringliteral">&quot;Cyild::ReadTree (1)&quot;</span>);</div><div class="line">    }</div><div class="line">    m_pNode[0].ind=0;</div><div class="line">    m_pNode[0].parent=-1;</div><div class="line">    m_pNode[0].prob=1;</div><div class="line">    m_pNode[0].period=0;</div><div class="line">    m_pNode[0].demand=0;</div><div class="line">    <span class="keywordtype">double</span> prob;</div><div class="line">    <span class="keywordtype">int</span> nodeNum, leafNum, n, *d;</div><div class="line">    sNode *pNode=m_pNode+1;</div><div class="line">    leafNum=0;</div><div class="line">    nodeNum=m_iNodeNum;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> t,j=1; j &lt; nodeNum; ++j, ++pNode) {</div><div class="line">        fin &gt;&gt; pNode-&gt;ind &gt;&gt; pNode-&gt;parent &gt;&gt; prob;</div><div class="line">        pNode-&gt;period=t=m_pNode[pNode-&gt;parent].period+1;</div><div class="line">        pNode-&gt;prob=m_pNode[pNode-&gt;parent].prob * prob;</div><div class="line">        <span class="keywordflow">if</span> (t == m_iT)</div><div class="line">            ++leafNum;</div><div class="line">        n=m_iOptNum;</div><div class="line">        <span class="keywordflow">if</span> (!(pNode-&gt;demand=d=<span class="keyword">new</span>(std::nothrow) <span class="keywordtype">int</span>[3*n])) {</div><div class="line">            fin.close();</div><div class="line">            <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMemoryException.html">CMemoryException</a>(<span class="stringliteral">&quot;Cyild::ReadTree (2)&quot;</span>);</div><div class="line">        }</div><div class="line">        n*=3;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; n; ++i)</div><div class="line">            fin &gt;&gt; d[i];        </div><div class="line">    }</div><div class="line">    m_iLeafNum=leafNum;</div><div class="line">    fin.close();</div><div class="line">} <span class="comment">// end of Cyield::readTree()</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> Cyield::readData(<span class="keyword">const</span> <span class="keywordtype">char</span>* name)</div><div class="line">{</div><div class="line">    readParameters();</div><div class="line">    readOptions();</div><div class="line">    readTree();</div><div class="line">} <span class="comment">// end of Cyield::readData()</span></div></div><!-- fragment --></p>
<p>Implementation of the above functions is straightforward and must be clear from our description of the files <code>param.txt</code>, <code>options.txt</code>, and <code>tree.txt</code> that represent our illustrative example problem.</p>
<p>Now it is left to present our <b>MIPshell</b> implementation of IP (1).</p>
<div class="fragment"><div class="line">#define c(j,i,o) (m_pNode[j].prob*m_dpCost[(m_pNode[j].period*3+o)*m+i])</div><div class="line">#define d(j,i,o) m_pNode[j].demand[o*m+i]</div><div class="line">#define parent(j) m_pNode[j].parent</div><div class="line">#define s(k) m_pPlane[k].num</div><div class="line">#define q1(k) m_pPlane[k].q1</div><div class="line">#define q2(k) m_pPlane[k].q2</div><div class="line">#define q3(k) m_pPlane[k].q3</div><div class="line">#define r1(k) m_pPlane[k].r1</div><div class="line">#define r2(k) m_pPlane[k].r2</div><div class="line">#define r3(k) m_pPlane[k].r3</div><div class="line">#define f(k)  m_pPlane[k].cost</div><div class="line"></div><div class="line">int Cyield::model()</div><div class="line">{</div><div class="line">    int i,j,k,o,t,</div><div class="line">        T=m_iT, n=m_iNodeNum,</div><div class="line">        n0=m_iNodeNum-m_iLeafNum,</div><div class="line">        m=m_iOptNum, I=3,</div><div class="line">        K=m_iPlaneTypeNum;</div><div class="line">    </div><div class="line">    VAR_VECTOR v(&quot;v&quot;,INT_GE,K);</div><div class="line">    VAR_VECTOR x(&quot;x&quot;,INT_GE,n,I,m), // x[0] is not used </div><div class="line">               y(&quot;y&quot;,BIN,n0,m), z(&quot;z&quot;,INT_GE,n,I);</div><div class="line"></div><div class="line">    maximize(</div><div class="line">     sum(j in [1,n), o in [0,m), i in [0,I)) c(j,i,o)*x(j,i,o)</div><div class="line">     - sum(k in [0,K)) f(k)*v(k)</div><div class="line">    );</div><div class="line">    </div><div class="line">    forall(j in [0,n0))</div><div class="line">        sum(o in [0,m)) y(j,o) == 1;</div><div class="line"></div><div class="line">    forall(j in [1,n), i in [0,I), o in [0,m))</div><div class="line">        x(j,i,o) &lt;= d(j,i,o)*y(parent(j),o);</div><div class="line">        </div><div class="line">    z(0,0) == 0;</div><div class="line">    z(0,1) == 0;</div><div class="line">    z(0,2) == 0;</div><div class="line">    </div><div class="line">    forall(j in [1,n), i in [0,I))</div><div class="line">        z(j,i) == z(parent(j),i) + sum(o in [0,m)) x(j,i,o);</div><div class="line">        </div><div class="line">    forall(j in [n0,n)) {</div><div class="line">        z(j,0) &lt;= sum(k in [0,K)) (q1(k) + (r2(k)*q2(k))/100)*v(k);</div><div class="line">        z(j,1) &lt;= sum(k in [0,K)) (q2(k) + (r1(k)*q1(k)+r3(k)*q3(k))/100)*v(k);</div><div class="line">        z(j,2) &lt;= sum(k in [0,K)) (q3(k) + (r2(k)*q2(k))/100)*v(k);</div><div class="line">        z(j,0) + z(j,2) &lt;= sum(k in [0,K)) (q1(k)+q3(k)+(r2(k)*q2(k))/100)*v(k);</div><div class="line">        z(j,0) + z(j,1) + z(j,2) &lt;= sum(k in [0,K)) (q1(k)+q2(k)+q3(k))*v(k);</div><div class="line">    }</div><div class="line">    </div><div class="line">    forall(k in [0,K))</div><div class="line">        v(k) &lt;= s(k);</div><div class="line">            </div><div class="line">    optimize();</div><div class="line">    printsol();</div><div class="line">    return 0;</div><div class="line">} // end of Cyield::model</div></div><!-- fragment --><p>First, we introduce a number of macros that translate <code>Cyild</code> members into parameters of IP (1). With these macros <b>MIPshell</b> implementation of IP (1) is straightforward.</p>
<h2><a class="anchor" id="mipshell_YieldExampleSol"></a>
Solution of Illustrative Example</h2>
<p>To solve our example problem presented earlier, we have to write down input data into a number of text files. These files are situated in the folder </p><pre class="fragment"> $MIPDIR/examples/yield/tests/test1
</pre><p>and are presented in Listings&#160;1&ndash;3.</p>
<p><b> Listing&#160;1: <em>Yield management example</em></b>: file <code>param.txt</code> </p><pre class="fragment">3  1
6  75000  35 10  40 10   60 10
</pre><p>From Listing&#160;1 we see that we are to solve an instance with the following parameters: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} &amp;T=3,\; K=1,\; s_1=6,\; f_1=\$75000,\; q_{11}=35,\\ &amp;r_{11}=10,\; q_{12}=40,\; r_{12}=10,\; q_{13}=60,\; r_{13}=10. \end{align*}" src="form_194.png"/>
</p>
<p><b> Listing&#160;2: <em>Yield management example</em></b>: file <code>options.txt</code> </p><pre class="fragment">3
1500 1000 500
1250  850 400
1000  700 300

1750 1250 700
1500 1000 500
1250  850 400

1800  800 450
1200  850 500
900  600 450
</pre><p>Listing&#160;2 shows that three (the number in the first line) options are available in each of three periods. Starting from Line&#160;2, each group of three lines represents price options for each of three periods. Any line in a group presents an option for a particular scenario. An option is described by three numbers that are prices of first, business, and economy class tickets respectively. For example, if Scenario&#160;3 happens in Period&#160;2, then ticket prices are: $1250 for first class, $850 for business class, and $400 for economy class.</p>
<p><b>Listing&#160;3: <em>Yield management example</em></b>: file <code>tree.txt</code> </p><pre class="fragment"> 39
 1   0   0.1   25  40 100   30  50 120   35  70 130
 2   0   0.6   40  90 100   50  85 100   70  90 140
 3   0   0.3   90  90 110  100  95 105  120  95 135

 4   1   0.1   40  85 100   50  90 105   65  85 125
 5   1   0.6   20 100 120   80 120 130  100 160 180
 6   1   0.3  100  40  25  110  60  80  160 100 120
 7   2   0.1   40  85 100   50  90 105   65  85 125
 8   2   0.6   20 100 120   80 120 130  100 160 180
 9   2   0.3  100  40  25  110  60  80  160 100 120
10   3   0.1   40  85 100   50  90 105   65  85 125
11   3   0.6   20 100 120   80 120 130  100 160 180
12   3   0.3  100  40  25  110  60  80  160 100 120

13   4   0.1   60  80 100   70 100 120   80 110 160
14   4   0.6   60  20 100   80  80 120  120  90 140
15   4   0.3  100  80 120  140  90 130  160 120 140
16   5   0.1   60  80 100   70 100 120   80 110 160
17   5   0.6   60  20 100   80  80 120  120  90 140
18   5   0.3  100  80 120  140  90 130  160 120 140
19   6   0.1   60  80 100   70 100 120   80 110 160
20   6   0.6   60  20 100   80  80 120  120  90 140
21   6   0.3  100  80 120  140  90 130  160 120 140
22   7   0.1   60  80 100   70 100 120   80 110 160
23   7   0.6   60  20 100   80  80 120  120  90 140
24   7   0.3  100  80 120  140  90 130  160 120 140
25   8   0.1   60  80 100   70 100 120   80 110 160
26   8   0.6   60  20 100   80  80 120  120  90 140
27   8   0.3  100  80 120  140  90 130  160 120 140
28   9   0.1   60  80 100   70 100 120   80 110 160
29   9   0.6   60  20 100   80  80 120  120  90 140
30   9   0.3  100  80 120  140  90 130  160 120 140
31  10   0.1   60  80 100   70 100 120   80 110 160
32  10   0.6   60  20 100   80  80 120  120  90 140
33  10   0.3  100  80 120  140  90 130  160 120 140
34  11   0.1   60  80 100   70 100 120   80 110 160
35  11   0.6   60  20 100   80  80 120  120  90 140
36  11   0.3  100  80 120  140  90 130  160 120 140
37  12   0.1   60  80 100   70 100 120   80 110 160
38  12   0.6   60  20 100   80  80 120  120  90 140
39  12   0.3  100  80 120  140  90 130  160 120 140
</pre><p>Listing&#160;3 describes the scenario tree for our example. This tree has 40 nodes indexed from 0 to 39. All the other nodes are split into three levels:</p><ul>
<li>1 (the root node) in Level&#160;0,</li>
<li>3 in Level&#160;1,</li>
<li>9 in Level&#160;2,</li>
<li>and 27 in Level&#160;3.</li>
</ul>
<p>In <code>tree.txt</code> there is no record that describes the root node 0, the levels are separated by blank lines, and any line, starting from the second, describes a node in the following format:</p><ul>
<li>node index;</li>
<li>parent node index;</li>
<li>probability of reaching this node from its parent;</li>
<li>demand forecast for each of three options (for example, if option~2 is used at node~27, then a business class ticket price is $90$).</li>
</ul>
<p>Having been prepared these three input files, to solve our example, we enter the commands </p><pre class="fragment">cd $MIPDIR/examples/yield/tests/test1; yield
</pre><p>As the result we will get a solution to our example written into the text file <code>test1.sol</code>.</p>
<p>In fact, we are interested to know the values of nine variables: <code>x(0,i,o), i,o=0,1,2</code>. Only three of these nine variables can take nonzero values. If we look into <code>test1.sol</code>, we will see that these three variables are: </p><center> <code>x(0,0,0)=25,</code>x(0,1,0)=40<code>,</code>x(0,2,0)=100`. </center><p>We see that Option&#160;1 (indexed by 0 in <b>MIPshell</b> model) must be used in Period&#160;1, and then 25, 40, and 95 tickets of, respectively, classes 1, 2, and 3, are expected to be sold.</p>
<p>So let us assume that the airline assigned prices $1500, $1000, $500 for, respectively, first, busines, and economy class tickets. One week later, it turned out that the airline had sold 20, 50, and 100 tickets of, respectively, first, busines, and economy class tickets.</p>
<p>to be continued </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
