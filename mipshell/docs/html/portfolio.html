<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIPschell: Portfolio Optimization</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIPschell
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
   <div id="projectbrief">A language for writing Mixed Integer Programs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Portfolio Optimization </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="mipshell_optPortfolio"></a>
Portfolio Optimization (Markovitz's Model)</h1>
<p>H.~Markowitz received the 1990 Nobel Prize in Economics for his <em>portfolio optimization model</em> in which the return of a portfolio is measured by the expected value of the random portfolio return and the risk is measured by the variance of the portfolio return.</p>
<p>There are $n$ potential investments. We want to determine the share <img class="formulaInl" alt="$x_j$" src="form_121.png"/> of each investment <img class="formulaInl" alt="$j,\; x_j \ge 0,\; \sum_{j=1}^n x_j=1$" src="form_122.png"/>. Let <img class="formulaInl" alt="$R_j$" src="form_123.png"/> be a random variable denoted an yearly return (on each invested dollar) of investment <em>j</em>. Then the return (on each dollar) of the portfolio is </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R =\sum_{i=1}^n x_j R_j. \]" src="form_124.png"/>
</p>
<p> The <em>reward</em> associated with such a portfolio is defined as the expected return: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E(R) = \sum_{j=1}^n x_j E(R_j), \]" src="form_125.png"/>
</p>
<p> where <img class="formulaInl" alt="$E(R_j)$" src="form_126.png"/> is the <em>expected value</em> for the return of investment <em>j</em>.</p>
<p>If reward were the only issue, then the problem would be trivial: simply invest all the many in an assert with the highest return. Unfortunately, investments with high reward are typically of high level of risk. Markowitz defined the <em>risk</em> associated with the portfolio to be the variance of the return: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \mathrm{var}(R) &amp;= E((R-E(R))^2) = E((\sum_{j=1}^n x_j(R_j-E(R_j)))^2)\\ &amp;= E((\sum_{j=1}^n x_j \bar{R}_j)^2). \end{align*}" src="form_127.png"/>
</p>
<p> where <img class="formulaInl" alt="$\bar{R}_j= R_j-E(R_j)$" src="form_128.png"/>.</p>
<p>One would like to maximize the reward keeping the risk below some level <em>V</em>: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{j=1}^n E(R_j) x_j &amp;\to \max,\\ \sum_{j=1}^n x_j &amp;= 1,\\ E((\sum_{j=1}^n x_j \bar{R}_j)^2) &amp;\le V,\\ x_j &amp;\ge 0,\quad j=1,\ldots,n. \end{align*}" src="form_129.png"/>
</p>
<h2><a class="anchor" id="mipshell_optPortfolioAvReturn"></a>
Computing Average Returns</h2>
<p>For stocks, it is common to compute variances from historical data. Expected returns may be either computed from historical data or estimated from market research data.</p>
<p>Table 1 shows annual returns from 1973 to 1994 for 8 investments. Let $R_{jt}$ denote the return of assert <em>j</em> in year <em>1972+t</em>. One way to estimate the mean <img class="formulaInl" alt="$E(R_j)$" src="form_126.png"/> is to take the average of the historical returns: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_1(R_j) = \frac{1}{T}\sum_{t=1}^T R_{jt}.\qquad\qquad (1)\]" src="form_130.png"/>
</p>
<p>There are two objections to this simple formula. First, whatever happened in 1973 certainly has less impact on the future than what happened in 1994. A better estimate is obtained by using the discount sum </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_2(R_j) = \frac{\sum_{t=1}^T p^{T-t}R_{jt}}{\sum_{t=1}^T p^{T-t}},\qquad\qquad (2)\]" src="form_131.png"/>
</p>
<p> where <em>p</em> ( <img class="formulaInl" alt="$0 &lt; p &lt; 1$" src="form_132.png"/>) is a discount factor. In the estimations that follow, <em>p</em>=0.9. To see the effect of discounting the past, let us consider the Gold investment. The average return computed by (1) is <code>1.129</code>, whereas the weighted average return computed by (2) is <code>1.053</code>. Most experts in 1995 felt that a 5.3% return was more realistic than a 12.9% return.</p>
<p>The second objection concerns the estimation of means (not variances). An investment that returns 1.1 one year and 0.9 the next has an average (computed by (1)) return of 1, that is, no gain or loss. However, one dollar invested will actually be worth <code>1.1 x 0.9 = 0.99 &lt; 1</code> at the end of the second year. Of course, a 1% error is fairly small. But let us consider what happens if the return is 2.0 one year and <code>0.5</code> the next. Clearly the value of one dollar at the end of two years is <code>2.0 x 0.5 =1</code>, but the average of two returns is <code>(2.0+0.5)/2=1.25</code>. The difference between an investment that is flat and one that yields a 25% return is very significant. The remedy is to average the logarithms of the returns and then exponentiate the average: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[E_3(R_j) = \exp\left(\frac{\sum_{t=1}^T p^{T-t}\log R_{jt}}{\sum_{t=1}^T p^{T-t}}\right).\qquad\qquad (3) \]" src="form_133.png"/>
</p>
<p>The trick is in that the logarithm cancels a return $r$ and its reciprocal: log(<em>r</em>) + log(1/_r_) =0.</p>
<center> <table class="doxtable">
<tr>
<th align="center">Year </th><th align="center">US 3-Month T-Bills </th><th align="center">US Gov. Long Bonds </th><th align="center">S &amp; P 500</th><th align="center">Wilshire 5000 </th><th align="center">NASDAQ Comp. </th><th align="center">Lehman Bros. Corp. Bonds </th><th align="center">EAFE </th><th align="center">Gold  </th></tr>
<tr>
<td align="center">1973 </td><td align="center">1.075 </td><td align="center">0.942 </td><td align="center">0.852 </td><td align="center">0.815 </td><td align="center">0.698 </td><td align="center">1.023 </td><td align="center">0.851 </td><td align="center">1.677 </td></tr>
<tr>
<td align="center">1974 </td><td align="center">1.084 </td><td align="center">1.020 </td><td align="center">0.735 </td><td align="center">0.716 </td><td align="center">0.662 </td><td align="center">1.002 </td><td align="center">0.768 </td><td align="center">1.722 </td></tr>
<tr>
<td align="center">1975 </td><td align="center">1.061 </td><td align="center">1.056 </td><td align="center">1.371 </td><td align="center">1.385 </td><td align="center">1.318 </td><td align="center">1.123 </td><td align="center">1.354 </td><td align="center">0.760 </td></tr>
<tr>
<td align="center">1976 </td><td align="center">1.052 </td><td align="center">1.175 </td><td align="center">1.236 </td><td align="center">1.266 </td><td align="center">1.280 </td><td align="center">1.156 </td><td align="center">1.025 </td><td align="center">0.960 </td></tr>
<tr>
<td align="center">1977 </td><td align="center">1.055 </td><td align="center">1.002 </td><td align="center">0.926 </td><td align="center">0.974 </td><td align="center">1.093 </td><td align="center">1.030 </td><td align="center">1.181 </td><td align="center">1.200 </td></tr>
<tr>
<td align="center">1978 </td><td align="center">1.077 </td><td align="center">0.982 </td><td align="center">1.064 </td><td align="center">1.093 </td><td align="center">1.146 </td><td align="center">1.012 </td><td align="center">1.326 </td><td align="center">1.295 </td></tr>
<tr>
<td align="center">1979 </td><td align="center">1.109 </td><td align="center">0.978 </td><td align="center">1.184 </td><td align="center">1.256 </td><td align="center">1.307 </td><td align="center">1.023 </td><td align="center">1.048 </td><td align="center">2.212 </td></tr>
<tr>
<td align="center">1980 </td><td align="center">1.127 </td><td align="center">0.947 </td><td align="center">1.323 </td><td align="center">1.337 </td><td align="center">1.367 </td><td align="center">1.031 </td><td align="center">1.226 </td><td align="center">1.296 </td></tr>
<tr>
<td align="center">1981 </td><td align="center">1.156 </td><td align="center">1.003 </td><td align="center">0.949 </td><td align="center">0.963 </td><td align="center">0.990 </td><td align="center">1.073 </td><td align="center">0.997 </td><td align="center">0.688 </td></tr>
<tr>
<td align="center">1982 </td><td align="center">1.117 </td><td align="center">1.465 </td><td align="center">1.215 </td><td align="center">1.187 </td><td align="center">1.213 </td><td align="center">1.311 </td><td align="center">0.981 </td><td align="center">1.084 </td></tr>
<tr>
<td align="center">1983 </td><td align="center">1.092 </td><td align="center">0.985 </td><td align="center">1.224 </td><td align="center">1.235 </td><td align="center">1.217 </td><td align="center">1.080 </td><td align="center">1.237 </td><td align="center">0.872 </td></tr>
<tr>
<td align="center">1984 </td><td align="center">1.103 </td><td align="center">1.159 </td><td align="center">1.061 </td><td align="center">1.030 </td><td align="center">0.903 </td><td align="center">1.150 </td><td align="center">1.074 </td><td align="center">0.825 </td></tr>
<tr>
<td align="center">1985 </td><td align="center">1.080 </td><td align="center">1.366 </td><td align="center">1.316 </td><td align="center">1.326 </td><td align="center">1.333 </td><td align="center">1.213 </td><td align="center">1.562 </td><td align="center">1.006 </td></tr>
<tr>
<td align="center">1986 </td><td align="center">1.063 </td><td align="center">1.309 </td><td align="center">1.186 </td><td align="center">1.161 </td><td align="center">1.086 </td><td align="center">1.156 </td><td align="center">1.694 </td><td align="center">1.216 </td></tr>
<tr>
<td align="center">1987 </td><td align="center">1.061 </td><td align="center">0.925 </td><td align="center">1.052 </td><td align="center">1.023 </td><td align="center">0.959 </td><td align="center">1.023 </td><td align="center">1.246 </td><td align="center">1.244 </td></tr>
<tr>
<td align="center">1988 </td><td align="center">1.071 </td><td align="center">1.086 </td><td align="center">1.165 </td><td align="center">1.179 </td><td align="center">1.165 </td><td align="center">1.076 </td><td align="center">1.283 </td><td align="center">0.861 </td></tr>
<tr>
<td align="center">1989 </td><td align="center">1.087 </td><td align="center">1.212 </td><td align="center">1.316 </td><td align="center">1.292 </td><td align="center">1.204 </td><td align="center">1.142 </td><td align="center">1.105 </td><td align="center">0.977 </td></tr>
<tr>
<td align="center">1990 </td><td align="center">1.080 </td><td align="center">1.054 </td><td align="center">0.968 </td><td align="center">0.938 </td><td align="center">0.830 </td><td align="center">1.083 </td><td align="center">0.766 </td><td align="center">0.922 </td></tr>
<tr>
<td align="center">1991 </td><td align="center">1.057 </td><td align="center">1.193 </td><td align="center">1.304 </td><td align="center">1.342 </td><td align="center">1.594 </td><td align="center">1.161 </td><td align="center">1.121 </td><td align="center">0.958 </td></tr>
<tr>
<td align="center">1992 </td><td align="center">1.036 </td><td align="center">1.079 </td><td align="center">1.076 </td><td align="center">1.090 </td><td align="center">1.174 </td><td align="center">1.076 </td><td align="center">0.878 </td><td align="center">0.926 </td></tr>
<tr>
<td align="center">1993 </td><td align="center">1.031 </td><td align="center">1.217 </td><td align="center">1.100 </td><td align="center">1.113 </td><td align="center">1.162 </td><td align="center">1.110 </td><td align="center">1.326 </td><td align="center">1.146 </td></tr>
<tr>
<td align="center">1994 </td><td align="center">1.045 </td><td align="center">0.889 </td><td align="center">1.012 </td><td align="center">0.999 </td><td align="center">0.968 </td><td align="center">0.965 </td><td align="center">1.078 </td><td align="center">0.990 </td></tr>
</table>
<b>Table 1: <em>Returns per dollar for</em> 8 <em>investments</em></b> </center> <h2><a class="anchor" id="mipshell_optPortfolioQP"></a>
Quadratic Programming Formulation</h2>
<p>In view of discussion of the previous section, the portfolio optimization program can be rewritten as follows </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{equation} \renewcommand{\theequation}{4} \begin{aligned} \sum_{j=1}^n E_3(R_j) x_j &amp;\to \max,\\ \sum_{j=1}^n x_j &amp;= 1,\\ E_2\left(\left(\sum_{j=1}^n x_j \bar{R}_j\right)^2\right) &amp;\le V,\\ x_j &amp;\ge 0,\quad j=1,\dots,n. \end{aligned} \end{equation}" src="form_134.png"/>
</p>
<p> Using notations </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ p_t = \frac{p^{T-t}}{\sum_{\tau=1}^T p^{T-\tau}},\quad t=1,\dots,T, \]" src="form_135.png"/>
</p>
<p> and </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \tilde{R}_{jt} = R_{jt} - \sum_{\tau=1}^T p_{\tau} R_{j\tau},\quad j=1,\dots,n,\; t=1,\dots,T, \]" src="form_136.png"/>
</p>
<p> we have </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ E_2\left(\left(\sum_{j=1}^n x_j \bar{R}_j\right)^2\right) = \sum_{t=1}^T p_t\left(\sum_{j=1}^n x_j\tilde{R}_{jt}\right)^2, \]" src="form_137.png"/>
</p>
<p> If we denote <img class="formulaInl" alt="$E_3(R_j)$" src="form_138.png"/> by <img class="formulaInl" alt="$\mu_j$" src="form_139.png"/>, and introduce the following variables </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ y_t = \sum_{j=1}^n \tilde{R}_{jt} x_j,\quad t=1,\dots,T, \]" src="form_140.png"/>
</p>
<p> we can reformulate program (4) as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \sum_{j=1}^n \mu_j x_j &amp;\to \max,\tag{$5$}\\ \sum_{j=1}^n x_j &amp;= 1,\tag{$6$}\\ \sum_{j=1}^n \tilde{R}_{jt} x_j &amp;= y_t,\quad t=1,\dots,T,\tag{$7$}\\ \sum_{t=1}^T p_t y_t^2 &amp;\le V,\tag{$8$}\\ x_j &amp;\ge 0,\quad j=1,\dots,n.\tag{$9$} \end{align}" src="form_141.png"/>
</p>
<h2><a class="anchor" id="mipshell_optPortfolioImpl"></a>
MIPshell Implementation</h2>
<p>Although MIP solvers are not intended for solving quadratic programming problems, we can use <b>MIPCL</b> in our implementation of problem (5)&ndash;(9). And such approach even may be practical when additional logical constraints are added to the base problem (5)&ndash;(9). For instance, to simplify management of the portfolio, it is required that our portfolio have at most <em>q</em> investments, and the share of any investment <em>j</em> be not less than <img class="formulaInl" alt="$l_j$" src="form_142.png"/>. We model this requirement by introducing binary variables <img class="formulaInl" alt="$v_j\; (j=1,\dots,n)$" src="form_143.png"/> with <img class="formulaInl" alt="$v_j=1$" src="form_144.png"/> if the share of investment <em>j</em> is positive ( <img class="formulaInl" alt="$x_j &gt; 0$" src="form_145.png"/>), and <img class="formulaInl" alt="$v_j=0$" src="form_146.png"/> otherwise. With these variables we write the following inequalities: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \sum_{j=1}^n v_j &amp;\le q,\tag{$10$}\\ x_j &amp;\le v_j,\quad j=1,\dots,n.\tag{$11$} \end{align}" src="form_147.png"/>
</p>
<p>To solve (5)&ndash;(11) using <b>MIPCL</b> we have to represent quadratic inequality (8) by a separation procedure. Given a point <img class="formulaInl" alt="$\bar{y}\in\mathbb{R}^T$" src="form_148.png"/>, this procedure computes </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \delta=\sum_{t=1}^T p_t \bar{y}_t^2, \]" src="form_149.png"/>
</p>
<p> and if <img class="formulaInl" alt="$\delta &gt; V$" src="form_150.png"/>, separates <img class="formulaInl" alt="$\bar{y}$" src="form_151.png"/> by the inequality </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{t=1}^T (p_t\bar{y}_t) y_t \le \sqrt{V\delta}.\]" src="form_152.png"/>
</p>
<p> Indeed, this inequality is violated by <img class="formulaInl" alt="$\bar{y}$" src="form_151.png"/>. On the other hand, if <img class="formulaInl" alt="$\tilde{y}\in\mathbb{R}^T$" src="form_153.png"/> satisfies (8), then, for <img class="formulaInl" alt="$\epsilon=\sum_{t=1}^T p_t \tilde{y}_t^2 \le V$" src="form_154.png"/>, </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align*} \sum_{t=1}^T (p_t\bar{y}_t) \tilde{y}_t &amp;= \sum_{t=1}^T (\sqrt{p_t}\,\bar{y}_t) (\sqrt{p_t}\,\tilde{y}_t) \le \sqrt{\sum_{t=1}^T p_t\bar{y}_t^2} \times \sqrt{\sum_{t=1}^T p_t\tilde{y}_t^2}\\ &amp;= \sqrt{\delta \epsilon} \le \sqrt{\delta V}. \end{align*}" src="form_155.png"/>
</p>
<p>To solve problem (5)&ndash;(11), we developed a <b>C++</b> class named <code>Coptportfolio</code> and defined as follows.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mipshell_8h.html">mipshell.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Coptportfolio: <span class="keyword">public</span> <a class="code" href="classCProblem.html">CProblem</a></div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> m_dTol, m_dZero, m_dV;</div><div class="line">    <span class="keywordtype">int</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCLP.html#a25af32c327f27ddc37b545b684b1648c">m_iN</a>, m_iT, m_iQ;</div><div class="line">    <span class="keywordtype">double</span>  *m_dpRet, *m_dpMu, *m_dpP, *m_dpL;</div><div class="line">    <a class="code" href="classCVarVector.html">VAR_VECTOR</a> *m_pY; <span class="comment">// without allocating memory</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Coptportfolio(<span class="keyword">const</span> <span class="keywordtype">char</span>* name);</div><div class="line"><span class="preprocessor">#ifndef __ONE_THREAD_</span></div><div class="line">    Coptportfolio(<span class="keyword">const</span> Coptportfolio &amp;other, <span class="keywordtype">int</span> thread);</div><div class="line">    <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a>* <a class="code" href="classCProblem.html#a652138eae3153e0bbb7a8e78cb488600">clone</a>(<span class="keyword">const</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    <span class="keyword">virtual</span> ~Coptportfolio();</div><div class="line">    <span class="keywordtype">void</span> readData(<span class="keyword">const</span> <span class="keywordtype">char</span>* fileName);</div><div class="line">    <span class="keyword">static</span> <span class="keywordtype">double</span> getMean(<span class="keyword">const</span> <span class="keywordtype">double</span> p, <span class="keyword">const</span> <span class="keywordtype">int</span> T, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpR);</div><div class="line">    <span class="keywordtype">void</span> computeParameters(<span class="keyword">const</span> <span class="keywordtype">double</span> p);</div><div class="line">    <span class="keywordtype">int</span> model();</div><div class="line">    <span class="keywordtype">bool</span> <a class="code" href="classCProblem.html#a306040ccb9aed147f854527a6a7a8494">separate</a>();</div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p>Its members are:</p><ul>
<li><code>m_iN</code>: number of potential investments;</li>
<li><code>m_iT</code>: number of past periods;</li>
<li><code>m_dpRet</code>: real array of size <code>m_iN * m_iT</code>, where <code>m_dpRet[j*m_iT+t]</code> is return of asset <code>j</code> in year <code>t</code>;</li>
<li><code>m_dpL</code>: real array of size <code>m_iN</code>, where <code>m_dpL[j]</code> is minimum share of investment <code>j</code>;</li>
<li><code>m_iQ</code>: maximum number of investments in portfolio;</li>
<li><code>m_dV</code>: risk level;</li>
<li><code>m_dpMu</code>: real array of size <code>m_iN</code>, where <code>m_dpMu[j]</code> is the mean return of investment <code>j</code>;</li>
<li><code>m_dpP</code>: real array of size <code>m_iT</code>, where <code>m_dpP[t-1]</code> is <img class="formulaInl" alt="$\frac{p^{T-t}}{\sum_{t=1}^T p^{T-t}},\; t=1,\dots,T$" src="form_156.png"/>;</li>
<li><code>m_dTol</code>: tolerance value for violations of inequality (8);</li>
<li><code>m_dZero</code>: in <code>separate()</code>, the value of a variable <img class="formulaInl" alt="$y_t$" src="form_157.png"/> is treated as being zero if it is less than <code>m_dZero</code>.</li>
</ul>
<p>Next, we discuss the implementation of the constructors and the destructor of <code>Coptportfolio</code>.</p>
<p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div><div class="line"></div><div class="line">Coptportfolio::Coptportfolio(<span class="keyword">const</span> <span class="keywordtype">char</span>* name): <a class="code" href="classCProblem.html">CProblem</a>(name)</div><div class="line">{</div><div class="line">    m_dTol=0.0001;</div><div class="line">    m_dZero=1.0e-6;</div><div class="line">    m_dV=0.01;</div><div class="line">    m_dpL=0;</div><div class="line">    <span class="keywordtype">char</span> fileName[128];</div><div class="line">    strcpy(fileName,name);</div><div class="line">    strcat(fileName,<span class="stringliteral">&quot;.txt&quot;</span>);</div><div class="line">    readData(fileName);</div><div class="line">    computeParameters(0.9);</div><div class="line">}</div></div><!-- fragment --></p>
<p>First, two tolerance parameters and the risk level are set to their default values. Next <code>readData(fileName)</code> is called to read input data from the file which name is passed as the only input parameter <code>fileName</code>. Then <code>computeParameters()</code> is called to compute the mean returns as well as the values <code>m_dpP[t]</code>.</p>
<p>The implementations of the copy and clone constructors are standard.</p>
<p><div class="fragment"><div class="line">Coptportfolio::Coptportfolio(<span class="keyword">const</span> Coptportfolio &amp;other, <span class="keywordtype">int</span> thread): <a class="code" href="classCProblem.html">CProblem</a>(other,thread)</div><div class="line">{</div><div class="line">    m_dTol=other.m_dTol;</div><div class="line">    m_dZero=other.m_dZero;</div><div class="line">    m_iN=other.m_iN;</div><div class="line">    m_iT=other.m_iT;</div><div class="line">    m_iQ=other.m_iQ;</div><div class="line">    m_dV=other.m_dV;</div><div class="line">    m_dpRet=other.m_dpRet;</div><div class="line">    m_dpMu=other.m_dpMu;</div><div class="line">    m_dpP=other.m_dpP;</div><div class="line">    m_dpL=other.m_dpL;</div><div class="line">    m_pY=other.m_pY;</div><div class="line">} <span class="comment">// end of Coptportfolio::Coptportfolio(Coptportfolio &amp;other, int thread)</span></div><div class="line"></div><div class="line"><a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a>* Coptportfolio::clone(<span class="keyword">const</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a>*<span class="keyword">&gt;</span>(<span class="keyword">new</span> Coptportfolio(*static_cast&lt;Coptportfolio*&gt;(const_cast&lt;CMIP*&gt;(pMip)),thread));</div><div class="line">}</div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --></p>
<p>The destructor frees the memory allocated in <code>readData()</code>.</p>
<p><div class="fragment"><div class="line">Coptportfolio::~Coptportfolio()</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifndef __ONE_THREAD_</span></div><div class="line">    <span class="keywordflow">if</span> (!m_iThread) {</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">        <span class="keywordflow">if</span> (m_dpL)</div><div class="line">            <span class="keyword">delete</span>[] m_dpL;</div><div class="line"><span class="preprocessor">#ifndef __ONE_THREAD_</span></div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="preprocessor">} // end of Coptportfolio::~Coptportfolio</span></div></div><!-- fragment --></p>
<p>The implementation of <code>readData()</code> given below is straightforward, and you can easily guess the structure of an input file.</p>
<p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Coptportfolio::readData(<span class="keyword">const</span> <span class="keywordtype">char</span>* fileName)</div><div class="line">{</div><div class="line">    std::ifstream fin(fileName);</div><div class="line">    <span class="keywordflow">if</span> (!fin.is_open()) {</div><div class="line">        <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCFileException.html">CFileException</a>(<span class="stringliteral">&quot;Coptportfolio::readData&quot;</span>,fileName);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">int</span> n, T, q;</div><div class="line"></div><div class="line">    fin &gt;&gt; n &gt;&gt; m_iQ &gt;&gt; T;</div><div class="line">    m_iN=n; m_iT=T;</div><div class="line">    <span class="keywordflow">if</span> (!(m_dpL = <span class="keyword">new</span>(std::nothrow) <span class="keywordtype">double</span>[n*(T+2)+T])) {</div><div class="line">        <span class="keywordflow">throw</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMemoryException.html">CMemoryException</a>(<span class="stringliteral">&quot;Coptportfolio::readData&quot;</span>);</div><div class="line">    }</div><div class="line">    m_dpP=(m_dpMu=m_dpL+n)+n;</div><div class="line">    m_dpRet=m_dpP+T;</div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; n; ++j)</div><div class="line">        fin &gt;&gt; m_dpL[j];</div><div class="line">    </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> t=0; t &lt; T; ++t) {</div><div class="line">        fin &gt;&gt; q;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; n; ++j)</div><div class="line">            fin &gt;&gt; m_dpRet[j*T+t];</div><div class="line">    }</div><div class="line">    fin.close();</div><div class="line">} <span class="comment">// end of Coptportfolio::readData</span></div></div><!-- fragment --></p>
<p>The procedure <code>getMean()</code> computes the mean return (as defined by (3)) of an investment.</p>
<p><div class="fragment"><div class="line"><span class="keywordtype">double</span> Coptportfolio::getMean(<span class="keyword">const</span> <span class="keywordtype">double</span> p, <span class="keyword">const</span> <span class="keywordtype">int</span> T, <span class="keyword">const</span> <span class="keywordtype">double</span>* dpR)</div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> nom=0.0, den=0.0, f=1.0; </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> t=T; --t &gt;= 0;) {</div><div class="line">        nom+=f*log(dpR[t]);</div><div class="line">        den+=f;</div><div class="line">        f*=p;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> exp(nom/den);</div><div class="line">} <span class="comment">// end of Coptportfolio::getMean</span></div></div><!-- fragment --></p>
<p>Its parameters are:</p>
<ul>
<li><code>p</code>: discount factor;</li>
<li><code>T</code>: number of periods;</li>
<li><code>dpR</code>: arrasy of size <code>T</code>, where <code>dpR[t]</code> is return of the investment in period <code>t</code>.</li>
</ul>
<p>The procedure <code>computeParameters()</code> computes the mean returns <img class="formulaInl" alt="$\mu_j$" src="form_139.png"/> (stored in <code>m_dpMu[j]</code>), the values <img class="formulaInl" alt="$p_t$" src="form_158.png"/> (stored in <code>m_dpP[t]</code>), as well as the discounted returnes <img class="formulaInl" alt="$\tilde{R}_{jt}$" src="form_159.png"/> (stored in <code>m_dpRet[j*m_dT+t]</code>).</p>
<p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Coptportfolio::computeParameters(<span class="keyword">const</span> <span class="keywordtype">double</span> p)</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> n=m_iN, T=m_iT;</div><div class="line">    <span class="keywordtype">double</span> *dpR=m_dpRet, *dpP=m_dpP;</div><div class="line">    <span class="keywordtype">double</span> d=0.0, f=1.0;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; n; ++j) {</div><div class="line">        m_dpMu[j]=getMean(p,T,m_dpRet+j*T);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> t=T; --t &gt;= 0;) {</div><div class="line">        dpP[t]=f;</div><div class="line">        d+=f;</div><div class="line">        f*=p;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> t=0; t &lt; T; ++t) {</div><div class="line">        dpP[t]/=d;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; n; ++j) {</div><div class="line">        d=0.0;</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> tau=0; tau &lt; T; ++tau) {</div><div class="line">            d+=dpP[tau]*dpR[tau];</div><div class="line">        }</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> t=0; t &lt; T; ++t) {</div><div class="line">            dpR[t]-=d;</div><div class="line">        }</div><div class="line">        dpR+=T;</div><div class="line">    }</div><div class="line">} <span class="comment">// end of Coptportfolio::computeParameters</span></div></div><!-- fragment --></p>
<p>Its only parameter <code>p</code> is a discount factor.</p>
<p>Our _MIPshell__ implementation of MIP (5)&ndash;(11) is straightforward.</p>
<p><div class="fragment"><div class="line"><span class="preprocessor">#define l(j) m_dpL[j] </span></div><div class="line"><span class="preprocessor">#define mu(j) m_dpMu[j] </span></div><div class="line"><span class="preprocessor">#define a(j,t) m_dpRet[j*T+t]</span></div><div class="line"><span class="preprocessor">#define p(t) m_dpP[t]</span></div><div class="line"><span class="preprocessor">#define yv(t) m_dpArray[t]</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> Coptportfolio::model()</div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> j,t, n=m_iN, T=m_iT, q=m_iQ;</div><div class="line">    <a class="code" href="classCVarVector.html">VAR_VECTOR</a> x(<span class="stringliteral">&quot;x&quot;</span>,<a class="code" href="Var_8h.html#a1cec2e482ee71e7e701a8ef2025f8ebaa3e58089cdeaafd3168fd5c68f146ef81">REAL_GE</a>,n), v(<span class="stringliteral">&quot;v&quot;</span>,<a class="code" href="Var_8h.html#a1cec2e482ee71e7e701a8ef2025f8ebaa3dba92f17ebb0d7efe6056d51e9acdc7">BIN</a>,n), y(<span class="stringliteral">&quot;y&quot;</span>,<a class="code" href="Var_8h.html#a1cec2e482ee71e7e701a8ef2025f8ebaa053cb139f4b2333482449705c529b1e9">REAL</a>,T);</div><div class="line">    m_pY = &amp;y;</div><div class="line"></div><div class="line">    maximize(sum(j in [0,n)) mu(j)*x(j));</div><div class="line"></div><div class="line">    sum(j in [0,n)) x(j) == 1;</div><div class="line">    sum(j in [0,n)) v(j) &lt;= q;</div><div class="line"></div><div class="line">    forall(t in [0,T))</div><div class="line">        y(t) == sum(j in [0,n)) a(j,t)*x(j);</div><div class="line">        </div><div class="line">    forall (j in [0,n))</div><div class="line">        x(j) &gt;= l(j)*v(j);</div><div class="line">    </div><div class="line">    <a class="code" href="Problem_8h.html#a519b31597e2dfd997c765bd173d3c08b">preprocoff</a>(); <span class="comment">// to prevent elimination of y(t) variables</span></div><div class="line">    optimize();</div><div class="line">    <a class="code" href="Problem_8h.html#a71d33b1bbfc010c85e7d36ab2fe3f058">printsol</a>();</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">} <span class="comment">// end of Coptportfolio::model</span></div></div><!-- fragment --></p>
<p>To improve readability of the model, we introduced a few macros. Let us remember that <b>MIPCL</b> has a few arrays that are free for using in user defined procedures. Here we use an array <code>m_dpArray</code>, defined in <code>CMip</code>, to store the values of variables <code>y(t)</code>.</p>
<p>Now it is left to disscuss our implementation of <code>separate()</code> that solves the separation problem for quadratic inequality (8).</p>
<p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> Coptportfolio::separate()</div><div class="line">{</div><div class="line">    <span class="keywordtype">double</span> b,d=0.0, V=m_dV, zero=m_dZero;</div><div class="line">    <a class="code" href="classCVarVector.html">VAR_VECTOR</a> &amp;y=*m_pY;</div><div class="line">    <span class="keywordtype">int</span> T=m_iT;</div><div class="line">    <span class="keywordtype">bool</span> flag=<span class="keyword">false</span>;</div><div class="line">    </div><div class="line">    forall(<span class="keywordtype">int</span> t in [0,T)) {</div><div class="line">        yv(t)=<a class="code" href="Problem_8h.html#a029fa4f1fc382f0ddc992f769969cd0f">getval</a>(y(t));</div><div class="line">        d+=p(t)*yv(t)*yv(t);</div><div class="line">    }</div><div class="line">    b=sqrt(d*V);</div><div class="line">    <span class="keywordflow">if</span> (d &gt; b+m_dTol) {</div><div class="line">        flag=<span class="keyword">true</span>;</div><div class="line">        sum(<span class="keywordtype">int</span> t in [0,T): fabs(yv(t)) &gt; zero) (p(t)*yv(t))*y(t) &lt;= b;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> flag;</div><div class="line">} <span class="comment">// end of Coptportfolio::separate()</span></div></div><!-- fragment --></p>
<p>The first <code>forall</code>-loop computes the left hand side, <code>d</code>, of the most violated inequality. If <code>d</code> exceedes the risk level by more then <code>m_dTol</code>, the procedure generates (declares) the separating inequality, and sets the return value to <code>true</code>.</p>
<p>An application that uses <code>Coptportfolio</code> to solve the portfolio optimization problem can be found in the folder <code>$MIPCLDIR/examples/mipshell/optportfolio</code>, where the environment variable <code>MIPCLDIR</code> points to the <b>MIPCL</b> installation directory.</p>
<p>If we run the program with data from Table 1 and different risk values, we get the optimal portfolios presented in Table 2, where each row represent an optimal portfolio.</p>
<center> <table class="doxtable">
<tr>
<th align="right">No </th><th align="right">Risk </th><th align="right">Revard </th><th align="right">US 3-Month T-Bills </th><th align="right">US Gov. Long Bonds </th><th align="right">S &amp; P 500</th><th align="right">Wilshire 5000 </th><th align="right">NASDAQ Comp. </th><th align="right">Lehman Bros. Corp. Bonds </th><th align="right">EAFE </th><th align="right">Gold  </th></tr>
<tr>
<td align="right">1 </td><td align="right">0.0008 </td><td align="right">1.0737 </td><td align="right">0.858 </td><td align="right">0 </td><td align="right">0.056 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.064 </td><td align="right">0.022 </td><td align="right">0 </td></tr>
<tr>
<td align="right">2 </td><td align="right">0.001 </td><td align="right">1.0762 </td><td align="right">0.737 </td><td align="right">0 </td><td align="right">0.046 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.187 </td><td align="right">0.030 </td><td align="right">0 </td></tr>
<tr>
<td align="right">3 </td><td align="right">0.003 </td><td align="right">1.0887 </td><td align="right">0.509 </td><td align="right">0 </td><td align="right">0.277 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.166 </td><td align="right">0.048 </td><td align="right">0 </td></tr>
<tr>
<td align="right">4 </td><td align="right">0.005 </td><td align="right">1.0955 </td><td align="right">0.350 </td><td align="right">0 </td><td align="right">0.352 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.213 </td><td align="right">0.085 </td><td align="right">0 </td></tr>
<tr>
<td align="right">5 </td><td align="right">0.0075 </td><td align="right">1.1020 </td><td align="right">0.205 </td><td align="right">0 </td><td align="right">0.489 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.240 </td><td align="right">0.066 </td><td align="right">0 </td></tr>
<tr>
<td align="right">6 </td><td align="right">0.01 </td><td align="right">1.1076 </td><td align="right">0.074 </td><td align="right">0 </td><td align="right">0.544 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.283 </td><td align="right">0.099 </td><td align="right">0 </td></tr>
<tr>
<td align="right">7 </td><td align="right">0.015 </td><td align="right">1.1163 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.783 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.122 </td><td align="right">0.095 </td><td align="right">0 </td></tr>
<tr>
<td align="right">8 </td><td align="right">0.02 </td><td align="right">0.1208 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.669 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.331 </td><td align="right">0 </td></tr>
<tr>
<td align="right">9 </td><td align="right">0.03 </td><td align="right">1.1218 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.356 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.644 </td><td align="right">0 </td></tr>
<tr>
<td align="right">10 </td><td align="right">0.04 </td><td align="right">1.1224 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.167 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.833 </td><td align="right">0 </td></tr>
<tr>
<td align="right">11 </td><td align="right">0.05 </td><td align="right">1.2228 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.016 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0.984 </td><td align="right">0 </td></tr>
<tr>
<td align="right">12 </td><td align="right">0.06 </td><td align="right">1.2229 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0 </td><td align="right">0 </td><td align="right">1 </td><td align="right">0 </td></tr>
</table>
<b>Table 2: <em>Optimal portfolios for different risk values</em></b> </center> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
