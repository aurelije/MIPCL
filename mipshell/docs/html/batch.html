<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIPschell: Short-Term Scheduling in Chemical Industry</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIPschell
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
   <div id="projectbrief">A language for writing Mixed Integer Programs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Short-Term Scheduling in Chemical Industry </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="mipshell_batch"></a>
Short-Term Scheduling in Chemical Industry</h1>
<p>It is easier to start with an example from E.Kondili, C.C.Pantelides, and R.W.H.Sargent. A general algorithm for short-term scheduling of batch operations &mdash; I. MILP formulation. <em>Computers chem. Engng.</em> <b>17</b> (1993) 211&ndash;227.</p>
<p>Two products, 1 and 2, are produced from three different feedstocks A,B, and C according to the following recipe:</p><ul>
<li><b>Heating</b>: Heat A for 1h.</li>
<li><b>Reaction 1</b>: Mix 50% feed B and 50% feed C and let them for 2h to form intermediate BC.</li>
<li><b>Reaction 2</b>: Mix 40% hot A and 60% intermediate BC and let them react for 2h to form intermediate AB (60%) and product 1 (40%).</li>
<li><b>Reaction 3</b>: Mix 20% feed C and 80% intermediate AB and let them react for 1h to form impure E.</li>
<li><b>Separation</b>: Distill impure E to separate pure product 2 (90%, after 1h) and pure intermediate AB (10% after 2h). Discard the small amount of residue remaining at the end of the distillation. Recycle the intermediate AB.</li>
</ul>
<p>The above process is represented by the <em>State-Task-Network</em> (STN) shown in Figure 1.</p>
<div class="image">
<img src="stn.png" alt="stn.png"/>
<div class="caption">
Figure 1: State-task network for example process</div></div>
  The following processing equipment and storage capacity are available.</p><ul>
<li><b>Equipment</b>:<ul>
<li><em>Heater</em>: Capacity 100 kg, suitable for task 1;</li>
<li><em>Reactor 1</em>: Capacity 80 kg, suitable for tasks 2,3,4;</li>
<li><em>Reactor 2</em>: Capacity 50 kg, suitable for tasks 2,3,4;</li>
<li><em>Still</em>: Capacity 200 kg, suitable for task 5.</li>
</ul>
</li>
<li><b>Storage capacity</b>:<ul>
<li>For <em>feeds A,B,C</em>: unlimited;</li>
<li>For <em>hot A</em>: 100 kg;</li>
<li>For <em>intermediate AB</em>: 200 kg;</li>
<li>For <em>intermediate BC</em>: 150 kg;</li>
<li>For <em>intermediate E</em>: 100 kg;</li>
<li>For <em>products 1,2</em>: unlimited.</li>
</ul>
</li>
</ul>
<p>A number of parameters are associated with the tasks and the states defining the STN and with the available equipment items. More specifically:</p><ul>
<li><em>Task</em> <em>i</em> is defined by:<ul>
<li><img class="formulaInl" alt="$U_i$" src="form_97.png"/>: set of units capable of performing task <em>i</em>;</li>
<li><img class="formulaInl" alt="$S^{\mathrm{in}}_i$" src="form_98.png"/>: set of states that feed task <em>i</em>;</li>
<li><img class="formulaInl" alt="$S^{\mathrm{out}}_i$" src="form_99.png"/>: set of states that task <em>i</em> produces as its outputs;</li>
<li><img class="formulaInl" alt="$\rho^{\mathrm{in}}_{is}$" src="form_100.png"/>: proportion of input of task <em>i</em> from state <img class="formulaInl" alt="$s\in S^{\mathrm{in}}_i\,;\; \sum_{s\in S^{\mathrm{in}}_i} \rho^{\mathrm{in}}_{is} =1$" src="form_101.png"/>;</li>
<li><img class="formulaInl" alt="$\rho^{\mathrm{out}}_{is}$" src="form_102.png"/>: proportion of output of task <em>i</em> to state <img class="formulaInl" alt="$s\in S^{\mathrm{out}}_i\,;\; \sum_{s\in S^{\mathrm{out}}_i} \rho^{\mathrm{out}}_{is} =1$" src="form_103.png"/>;</li>
<li><img class="formulaInl" alt="$p_{is}$" src="form_68.png"/>: processing time for output of task <em>i</em> to state <img class="formulaInl" alt="$s\in S^{\mathrm{out}}_i$" src="form_104.png"/>;</li>
<li><img class="formulaInl" alt="$d_i$" src="form_105.png"/>: duration (completion time) for task <em>i</em>, <img class="formulaInl" alt="$d_i =\max_{s\in S^{\mathrm{out}}_i} p_{is}$" src="form_106.png"/>;</li>
</ul>
</li>
<li><em>State</em> <em>s</em> is defined by:<ul>
<li><img class="formulaInl" alt="$T^{\mathrm{out}}_s$" src="form_107.png"/>: set of tasks receiving material from state <em>s</em>;</li>
<li><img class="formulaInl" alt="$T^{\mathrm{in}}_s$" src="form_108.png"/>: set of tasks producing material in state <em>s</em>;</li>
<li><img class="formulaInl" alt="$z^0_s$" src="form_109.png"/>: initial stock in state <em>s</em>;</li>
<li><img class="formulaInl" alt="$u_s$" src="form_110.png"/>: storage capacity dedicated to state <em>s</em>;</li>
<li><img class="formulaInl" alt="$c^{\mathrm{P}}_{s}$" src="form_111.png"/>: unit cost (price) of product produced in state <em>s</em>;</li>
<li><img class="formulaInl" alt="$c^{\mathrm{S}}_{s}$" src="form_112.png"/>: cost of storing a unit amount of material in state <em>s</em>.</li>
</ul>
</li>
<li><em>Unit</em> <em>j</em> is characterized by:<ul>
<li><img class="formulaInl" alt="$I_j$" src="form_113.png"/>: set of tasks that can be performed by unit <em>j</em>;</li>
<li><img class="formulaInl" alt="$V^{\max}_{ij}, V^{\min}_{ij}$" src="form_114.png"/>: respectively, maximum and minimum load of unit <em>j</em> when used for performing task <em>i</em>.</li>
</ul>
</li>
</ul>
<p>Let <em>n</em>,<em>q</em>,<em>m</em> denote, respectively, the number of tasks, states, and units. The scheduling problem for batch processing system is stated as:</p><ul>
<li><b>Given</b>: the STN of a batch process and all the information associated with it, as well as a time horizon of interest.</li>
<li><b>Determine</b>: the timing of the operations for each unit (i.e. which task, if any, the unit performs at any time during the time horizon); and the flow of materials through the network.</li>
<li><b>Goal</b>: maximize the total cost of the products produced minus the total storage cost during the time horizon.</li>
</ul>
<h2><a class="anchor" id="mipshell_batchMIP"></a>
MIP formulation</h2>
<p>The time horizon of interest is divided into a number of intervals of equal duration. We number the intervals from 1 to H, and assume that interval <em>t</em> starts at time <em>t</em> and ends at time <em>t</em>+1. Events of any type &mdash; such as the start or end of processing individual batches of individual tasks, changes in the availability of processing equipment and etc. &mdash; are only happen at the interval boundaries. Preemptive operations are not allowed and materials are transferred instantaneously from states to tasks and from tasks to states.</p>
<p>We introduce the following variables:</p><ul>
<li><img class="formulaInl" alt="$x_{ijt}=1$" src="form_115.png"/> if unit <em>j</em> starts processing task <em>i</em> at the beginning of time period <em>t</em>; <img class="formulaInl" alt="$x_{ijt}=0$" src="form_116.png"/> otherwise;</li>
<li><img class="formulaInl" alt="$y_{ijt}$" src="form_117.png"/>: amount of material (batch size) that starts undergoing task <em>i</em> in unit <em>j</em> at the beginning of time period <em>t</em>.</li>
<li><img class="formulaInl" alt="$z_{st}$" src="form_118.png"/>: amount of material stored in state <em>s</em>, at the beginning of time period <em>t</em>. To simplify presentation,\ we introduce an additional time interval <em>H</em>+1 that represents the end of the time horizon. Then the value of $z_{s,H+1}$ is the amount of material in state <em>s</em> produced during the time horizon.</li>
</ul>
<p>Now the MIP model is written as follows: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{align} \sum_{s=1}^q c^{\mathrm{P}}_s z_{s,H+1} - \sum_{s=1}^q\sum_{t=1}^H c^{\mathrm{S}}_{s} z_{st} \to \max,\tag{1.a}\\ \sum_{i\in I_j} x_{ijt} \le 1, \quad j=1,\ldots,m;\; t=1,\ldots,H,\tag{1.b}\\ \sum_{l\in I_j} \sum_{\tau=t}^{t+d_i-1} x_{lj\tau} \le 1 + M(1-x_{ijt}), \quad j=1,\ldots,m;\; i\in I_j;\notag\\ t=1,\ldots,H,\tag{1.c}\\ V^{\min}_{ij} x_{ijt} \le y_{ijt}\le V^{\min}_{ij} x_{ijt}, \quad j=1,\ldots,m;\; i \in I_j;\notag\\ t=1,\ldots,H,\tag{1.d}\\ 0\le z_{st} \le u_s, \quad s=1,\ldots,q;\; t=1,\ldots,H,\tag{1.e}\\ z_{s,t-1} + \sum_{i\in T^{\mathrm{out}}_s:\: t &gt; p_{is}} \rho^{\mathrm{out}}_{is} \sum_{j\in U_i}y_{ij,t-p_{is}} = z_{st} + \sum_{i\in T^{\mathrm{in}}_s} \rho^{\mathrm{in}}_{is} \sum_{j\in U_i}y_{ijt}, \notag\\ s=1,\ldots,q; \; t=1,\ldots,H,\tag{1.f}\\ z_{s,H} + \sum_{i\in T^{\mathrm{out}}_s:\: t &gt; p_{is}} \rho^{\mathrm{out}}_{is} \sum_{j\in U_i}y_{ij,H-p_{is}} = z_{s,H+1}, \quad s=1,\ldots,q,\tag{1.g}\\ x_{ijt} = 0, \quad t &gt; H-d_i,\; j=1,\dots,m;\; i \in I_j,\tag{1.h}\\ x_{ijt}\in \{0,1\},\; y_{ijt}\in \mathbb{R}_+, \quad j=1,\ldots,m;\; i \in I_j; t=1,\ldots,H,\tag{1.i}\\ z_{st}\in \mathbb{R}_+, \quad s=1,\ldots,q;\; t=1,\dots,H + 1.\tag{1.j} \end{align}" src="form_119.png"/>
</p>
<p>The objective (1.a) is to maximize the total profit that equals the total cost of the produced materials minus the expenses for storing materials during the time horizon. The inequalities (1.b) enforce that at any time <em>t</em>, an idle unit <em>j</em> can only start one task. The constraints (1.c) impose the requirement that, if unit <em>j</em> starts performing task <em>i</em> at time <em>t</em>, then it cannot start any other task until <em>i</em> is finished. Used in (1.c), <em>M</em> is a sufficiently big number so that the constraint is only binding if <img class="formulaInl" alt="$x_{ijt}=1$" src="form_115.png"/>. The constraints (1.d) enforce that the batch size of any task must be within the minimum and maximum capacities of the unit performing the task. The constraints (1.e) impose stock limitations: the amount of material stored in any state <em>s</em> must not exceed the storage capacity for this state. The material balance constraints (1.f) require that for any state <em>s</em> at each period <em>t</em>, the amount of material entering the state (the stock from the previous period plus the input delivered from the tasks that finished at period <em>t</em>) equals the amount of material leaving the state (the stock at <em>t</em> plus the amount of material consumed by the tasks that started at <em>t</em>). Note that <img class="formulaInl" alt="$z_{s0}$" src="form_120.png"/> is not a variable but a constant <img class="formulaInl" alt="$z^0_s$" src="form_109.png"/>, the initial stock at state <em>s</em>. The constraints (1.g) are specializations of the balance constraints for period <em>H</em>+1, at this period no task starts. The constraints (1.h) enforce tasks finish within the time horizon.</p>
<h2><a class="anchor" id="mipshell_batchImpl"></a>
MIPshell Implementation</h2>
<p>Our test STN is described in a file whose contents is as follows.</p>
<p>### Test STN </p><div class="fragment"><div class="line">10 - time horizon</div><div class="line"></div><div class="line">begin(tasks)</div><div class="line">Heating</div><div class="line">{(Heater)}</div><div class="line">{(Fead_A)} 1.0</div><div class="line">{(Hot_A)} 1.0 1</div><div class="line">Reaction_1</div><div class="line">{(Reactor_1),(Reactor_2)}</div><div class="line">{(Fead_B),(Fead_C)} 0.5 0.5</div><div class="line">{(Int_BC)} 1.0 2</div><div class="line">Reaction_2</div><div class="line">{(Reactor_1),(Reactor_2)}</div><div class="line">{(Hot_A),(Int_BC)}  0.4  0.6</div><div class="line">{(Int_AB),(Prod_1)} 0.6 2   0.4 2</div><div class="line">Reaction_3</div><div class="line">{(Reactor_1),(Reactor_2)}</div><div class="line">{(Fead_C),(Int_AB)} 0.2 0.8</div><div class="line">{(Impure_E)} 1.0  1</div><div class="line">Separation</div><div class="line">{(Still)}</div><div class="line">{(Impure_E)} 1.0</div><div class="line">{(Int_AB),(Prod_2)} 0.1 2   0.9  1</div><div class="line">end(tasks)</div><div class="line"></div><div class="line">begin(states)</div><div class="line">Fead_A</div><div class="line">1000 1000 0.0 0.0</div><div class="line">Fead_B </div><div class="line">1000 1000 0.0 0.0</div><div class="line">Fead_C</div><div class="line">1000 1000 0.0 0.0</div><div class="line">Hot_A</div><div class="line">100 0.0 0.1 -1.0</div><div class="line">Int_AB</div><div class="line">200 0.0 0.1 -1.0</div><div class="line">Int_BC</div><div class="line">150 0.0 0.1 -1.0</div><div class="line">Impure_E</div><div class="line">100 0.0 0.1 -1.0</div><div class="line">Prod_1</div><div class="line">1000 0.0 0.0 10.0</div><div class="line">Prod_2</div><div class="line">1000 0.0 0.0 10.0</div><div class="line">end(states)</div><div class="line"></div><div class="line">begin(units)</div><div class="line">Heater</div><div class="line">{(Heating)}  0 100</div><div class="line">Reactor_1</div><div class="line">{(Reaction_1),(Reaction_2),(Reaction_3)}  0 80</div><div class="line">Reactor_2</div><div class="line">{(Reaction_1),(Reaction_2),(Reaction_3)}  0 50</div><div class="line">Still</div><div class="line">{(Separation)}  0 200</div><div class="line">end(units)Schedule <span class="keywordflow">for</span> example process</div></div><!-- fragment --><p>We see that there are five task. For example, the task named "Reaction~2" can be processed by the units Reactor_1 and Reactor_2. This task gets materials from states representing products Hot_A and Int_BC; these materials are mixed in the proportions of 40% and 60%. Furthermore, the task output materials are directed to states representing products Int_AB and Prod_1 in the proportions of 60% and 40%. Production of both output products takes two hours.</p>
<p>Next we have nine states. For instance, the state representing the intermediate product AB is described by the set {3} of task receiving product AB, the set {2,4} of task supplying the state, and the capacity of the state stock that equals 200kg, initial stock 0.0kg, and storing a unit of the product costs 0.1. It is undesirable to have any intermediate remaining in storage at the end of the horizon, and therefore the cost of all the intermediates is a negative value of -1. The three raw materials (Feed A, Feed B, and Feed C) are given costs of zero. A value of one kilogram of each of the two output products (Prod 1 and Prod 2) is 10 units.</p>
<p>The last section of the input file describes equipment units. Say, Reactor 1 can fulfill tasks Reaction_1, Reaction_2, Reaction_3, and has lower and upper capacities of zero and 80kg, respectively.</p>
<p>To solve the batch scheduling problem we developed a <b>C++</b> class, named <code>Cbatch</code>, which definition is as follow.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mipshell_8h.html">mipshell.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>Cbatch: <span class="keyword">public</span> <a class="code" href="classCProblem.html">CProblem</a></div><div class="line">{</div><div class="line">    <span class="keywordtype">int</span> H;  </div><div class="line">    <a class="code" href="classCSet.html">INDEX_SET</a> TASKS, STATES, UNITS;</div><div class="line">    <a class="code" href="classCArray.html">INDEX_SET_ARRAY</a> K, Sin, Sout, Tin, Tout, I;</div><div class="line">    <a class="code" href="classCArray.html">REAL_ARRAY</a> rho, u, z0, cs, cp, Vmin, Vmax; </div><div class="line">    <a class="code" href="classCArray.html">INT_ARRAY</a> p,dur;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Cbatch(<span class="keyword">const</span> <span class="keywordtype">char</span>* name);</div><div class="line"><span class="preprocessor">#ifdef __THREADS_</span></div><div class="line">    Cbatch(<span class="keyword">const</span> Cbatch &amp;other, <span class="keywordtype">int</span> thread);</div><div class="line">    <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a>* <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html#a33363f035bbd0ac5746cc4753886b013">clone</a>(<span class="keyword">const</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">    <span class="keyword">virtual</span> ~Cbatch();</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> readSTN(<span class="keyword">const</span> <span class="keywordtype">char</span> *fileName);</div><div class="line">    <span class="keywordtype">int</span> model();</div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="classCProblem.html#a1b7e983f014fb91903a35513531d9c3b">printSolution</a>(<a class="code" href="classCVarArray.html">VAR_ARRAY</a>&amp; y, <a class="code" href="classCVarArray.html">VAR_ARRAY</a>&amp; z);</div><div class="line">};</div><div class="line"></div></div><!-- fragment --><p>This class has the following members to describe problem instances:</p><ul>
<li><code>H</code>: number of time periods in planning horizon;</li>
<li><code>TASKS</code>: set of tasks;</li>
<li><code>STATES</code>: set of states;</li>
<li><code>UNITS</code>: set of units;</li>
<li><code>K</code>: array of sets, where <code>K(i)</code> is set of units capable of performing task <code>i</code>;</li>
<li><code>Sin</code>: array of sets, where <code>Sin(i)</code> is set of states that feed task <code>i</code>;</li>
<li><code>Sout</code>: array of sets, where <code>Sout(i)</code> is set of states to which task <em>i</em> produces as its outputs;</li>
<li><code>Tin</code>: array of sets, where <code>Tin(s)</code> is set of tasks producing material in state <code>s</code>;</li>
<li><code>Tout</code>: array of sets, where <code>Tin(s)</code> is set of tasks receiving material from state <code>s</code>;</li>
<li><code>I</code>: array of sets, where <code>I(j)</code> is set of tasks that can be performed by unit <code>j</code>;</li>
<li><code>rho</code>: two-dimensional real array, where <code>rho(i,j)</code> is proportion of input of task <code>i</code> from state <code>s</code> in <code>Sin(i)</code>;</li>
<li><code>u</code>: real array, where <code>u(s)</code> is storage capacity dedicated to state <code>s</code>;</li>
<li><code>z0</code>: real array, where <code>z0(s)</code> is initial stock in state <code>s</code>;</li>
<li><code>cs</code>: real array, where <code>cs(s)</code> is cost of storing a unit amount of material in state <code>s</code>;</li>
<li><code>cp</code>: real array, where <code>cp(s)</code> is unit cost (price) of product produced in state <code>s</code>;</li>
<li><code>Vmin</code>, <code>Vmax</code>: two-dimensional real arrays, where <code>Vmin(i,j)</code>, <code>Vmax(i,j)</code> are, respectively, maximum and minimum load of unit <code>j</code> when used for performing task <code>i</code>.</li>
<li><code>p</code>: two-dimensional integer array, where <code>p(i,s)</code> is processing time for output of task <code>i</code> to state <code>s</code> in <code>Sout(i)</code>;</li>
<li><code>dur</code>: integer array, where <code>dur(i)</code> is duration (completion time) for task <code>i</code>.</li>
</ul>
<p>The constructor <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div><div class="line"></div><div class="line">Cbatch::Cbatch(<span class="keyword">const</span> <span class="keywordtype">char</span>* name): <a class="code" href="classCProblem.html">CProblem</a>(name)</div><div class="line">{</div><div class="line">    <span class="keywordtype">char</span> fileName[128];</div><div class="line">    strcpy(fileName,name);</div><div class="line">    strcat(fileName,<span class="stringliteral">&quot;.txt&quot;</span>);</div><div class="line">    readSTN(fileName);</div><div class="line">}</div></div><!-- fragment --></p>
<p>gets on input the name (without extention <code>.txt</code>) of a file describing an STN, and then calls <code>readSTN()</code> to create an instance of <code>Cbatch</code> and initialize that instance whith data stored in the file.</p>
<p>The implementation of the copy and clone constructors, as well as the destructor are standard (i.e. they were generated by <code>mipinit</code>).</p>
<p><div class="fragment"><div class="line"><span class="preprocessor">#ifdef __THREADS_</span></div><div class="line">Cbatch::Cbatch(<span class="keyword">const</span> Cbatch &amp;other, <span class="keywordtype">int</span> thread): <a class="code" href="classCProblem.html">CProblem</a>(other,thread)</div><div class="line">{</div><div class="line"><span class="comment">// TODO: write your code here</span></div><div class="line">} <span class="comment">// end of Cbatch::Cbatch(Cbatch &amp;other, int thread)</span></div><div class="line"></div><div class="line"><a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a>* Cbatch::clone(<span class="keyword">const</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a> *pMip, <span class="keywordtype">int</span> thread)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a>*<span class="keyword">&gt;</span>(<span class="keyword">new</span> Cbatch(*static_cast&lt;Cbatch*&gt;(const_cast&lt;CMIP*&gt;(pMip)),thread));</div><div class="line">}</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">Cbatch::~Cbatch()</div><div class="line">{</div><div class="line"><span class="preprocessor">#ifdef __THREADS_</span></div><div class="line">    <span class="keywordflow">if</span> (!m_iThread) {</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="comment">// TODO: delete shared members </span></div><div class="line"><span class="preprocessor">#ifdef __THREADS_</span></div><div class="line">    }</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"><span class="comment">// TODO: delete notshared members </span></div><div class="line">} <span class="comment">// end of Cbatch::~Cbatch</span></div></div><!-- fragment --></p>
<p>As we have already mentioned <code>readSTN()</code> reads the description of an STN written in the text file which name (without extention <code>.txt</code>) is given as the only input parameter of <code>readSTN()</code>.</p>
<p><div class="fragment"><div class="line"><span class="keywordtype">void</span> Cbatch::readSTN(<span class="keyword">const</span> <span class="keywordtype">char</span>* fileName)</div><div class="line">{</div><div class="line">    std::ifstream fin(fileName);</div><div class="line">    <span class="keywordflow">if</span> (!fin.is_open()) {</div><div class="line">        <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCFileException.html">CFileException</a>(<span class="stringliteral">&quot;Cbatch::readSTN&quot;</span>,fileName);</div><div class="line">    }</div><div class="line">    <span class="keywordtype">char</span> str[256];</div><div class="line">    <span class="keywordtype">int</span> w,q;</div><div class="line">    <a class="code" href="classCIndex.html">INDEX</a> state, tsk, unit;</div><div class="line"></div><div class="line">    fin &gt;&gt; H;</div><div class="line"><span class="comment">// reading tasks</span></div><div class="line">    <span class="keywordflow">for</span> (fin.getline(str,255); strcmp(str,<span class="stringliteral">&quot;begin(tasks)&quot;</span>); fin.getline(str,255));</div><div class="line">    <span class="keywordflow">for</span> (fin &gt;&gt; str; strcmp(str,<span class="stringliteral">&quot;end(tasks)&quot;</span>); fin &gt;&gt; str) {</div><div class="line">        TASKS.add(tsk=str);</div><div class="line">        fin &gt;&gt; K.add(tsk);</div><div class="line">        fin &gt;&gt; Sin.add(tsk);</div><div class="line">        <span class="keywordflow">for</span> (Sin(tsk).initIt(); Sin(tsk).getNext(state);)</div><div class="line">            fin &gt;&gt; rho.add(state,tsk);</div><div class="line">        fin &gt;&gt; Sout.add(tsk);</div><div class="line">        w=0;</div><div class="line">        <span class="keywordflow">for</span> (Sout(tsk).initIt(); Sout(tsk).getNext(state);) {</div><div class="line">            fin &gt;&gt; rho.add(tsk,state) &gt;&gt; q;</div><div class="line">            p.add(tsk,state)=q;</div><div class="line">            <span class="keywordflow">if</span> (q &gt; w) w=q;</div><div class="line">        }</div><div class="line">        dur.add(tsk)=w;</div><div class="line">    }</div><div class="line"><span class="comment">// reading states</span></div><div class="line">    <span class="keywordflow">for</span> (fin.getline(str,255); strcmp(str,<span class="stringliteral">&quot;begin(states)&quot;</span>); fin.getline(str,255));</div><div class="line">    <span class="keywordflow">for</span> (fin &gt;&gt; str; strcmp(str,<span class="stringliteral">&quot;end(states)&quot;</span>); fin &gt;&gt; str) {</div><div class="line">        STATES.add(state=str);</div><div class="line">        Tin.add(state);</div><div class="line">        Tout.add(state);</div><div class="line">        fin &gt;&gt; u.add(state) &gt;&gt; z0.add(state) &gt;&gt; cs.add(state) &gt;&gt; cp.add(state);</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span> (TASKS.initIt(); TASKS.getNext(tsk);) {</div><div class="line">        <span class="keywordflow">for</span> (Sin(tsk).initIt(); Sin(tsk).getNext(state);)</div><div class="line">            Tout(state).add(tsk);</div><div class="line">        <span class="keywordflow">for</span> (Sout(tsk).initIt(); Sout(tsk).getNext(state);)</div><div class="line">            Tin(state).add(tsk);</div><div class="line">    }</div><div class="line"><span class="comment">// reading units</span></div><div class="line">    <span class="keywordflow">for</span> (fin.getline(str,255); strcmp(str,<span class="stringliteral">&quot;begin(units)&quot;</span>); fin.getline(str,255));</div><div class="line">    <span class="keywordflow">for</span> (fin &gt;&gt; str; strcmp(str,<span class="stringliteral">&quot;end(units)&quot;</span>); fin &gt;&gt; str) {</div><div class="line">        UNITS.add(unit=str);</div><div class="line">        fin &gt;&gt; I.add(unit) &gt;&gt; Vmin.add(unit) &gt;&gt; Vmax.add(unit);</div><div class="line">    }</div><div class="line">    fin.close();</div><div class="line">} <span class="comment">// end of Cbatch::readSTN</span></div></div><!-- fragment --></p>
<p>If you have any difficulties when reading the above code, we refer you to <a class="el" href="mipshell_primer.html#mipshell_inputOutput">Input/Output operations</a>.</p>
<p>Implementation of MIP (1) using directly <b>MIPCL</b> is not an easy exercice. <b>MIPshell</b> implementation given below is completely transparent and selfexplanatory. It is only worth mentioning that indices <code>tsk</code>, <code>unit</code> and <code>state</code> in the <b>MIPshell</b> model correspond to indices <em>i</em>, <em>j</em> and <em>s</em> in the mathematical model (1).</p>
<div class="fragment"><div class="line">int Cbatch::model()</div><div class="line">{</div><div class="line">    INDEX state, tsk, tsk1, unit;</div><div class="line">    int t,tau, M=H*TASKS.getSize();</div><div class="line">    RANGE HORIZON(0,H-1), HORIZON1(0,H);</div><div class="line">    VAR_ARRAY x(&quot;x&quot;,BIN,TASKS,UNITS,HORIZON), </div><div class="line">              y(&quot;y&quot;,REAL_GE,TASKS,UNITS,HORIZON), </div><div class="line">              z(&quot;z&quot;,REAL_GE,STATES,HORIZON1);</div><div class="line"></div><div class="line">    maximize(sum(state in STATES) cp(state)*z(state,H) </div><div class="line">       - sum(state in STATES, t in [0,H)) cs(state)*z(state,t));</div><div class="line"></div><div class="line">    forall(t in [0,H), unit in UNITS)</div><div class="line">        sum(tsk in I(unit)) x(tsk,unit,t) &lt;= 1;</div><div class="line">    forall(unit in UNITS, tsk in I(unit), t in [0,H))</div><div class="line">        sum(tsk1 in I(unit), tau in [t,t+dur(tsk)): tau &lt; H) x(tsk1,unit,tau) &lt;= 1 + M*(1-x(tsk,unit,t));</div><div class="line">    forall(unit in UNITS, tsk in I(unit), t in [0,H)) {</div><div class="line">        Vmin(unit)*x(tsk,unit,t) &lt;= y(tsk,unit,t);</div><div class="line">        y(tsk,unit,t) &lt;= Vmax(unit)*x(tsk,unit,t);</div><div class="line">        if (t+dur(tsk) &gt; H)</div><div class="line">            x(tsk,unit,t) == 0;</div><div class="line">    }</div><div class="line">    forall(state in STATES, t in [0,H)) </div><div class="line">        z(state,t) &lt;= u(state);</div><div class="line">    forall(state in STATES)</div><div class="line">        z0(state) == z(state,0) + sum(tsk in Tout(state), unit in K(tsk)) rho(state,tsk)*y(tsk,unit,0);</div><div class="line">    forall(state in STATES, t in [1,H))</div><div class="line">        z(state,t-1) + sum(tsk in Tin(state), unit in K(tsk): t &gt;= p(tsk,state)) rho(tsk,state)*y(tsk,unit,t-p(tsk,state)) ==</div><div class="line">        z(state,t) + sum(tsk in Tout(state), unit in K(tsk)) rho(state,tsk)*y(tsk,unit,t);</div><div class="line">    forall(state in STATES)</div><div class="line">        z(state,H) == z(state,H-1) + sum(tsk in Tin(state), unit in K(tsk): H &gt;= p(tsk,state)) rho(tsk,state)*y(tsk,unit,H-p(tsk,state));</div><div class="line"></div><div class="line">    optimize();</div><div class="line">    printSolution(y,z);</div><div class="line">    return 0;</div><div class="line">} // end of Cbatch::model</div></div><!-- fragment --><p>Before return, <code>model()</code> calls <code>printSolution()</code> that prints a solution in a readable format (presented below) to the text file which name is the name (without extention <code>.txt</code>) of the input file appended with the extention <code>.sol</code>.</p>
 <div class="fragment"><div class="line"><span class="keywordtype">void</span> Cbatch::printSolution(<a class="code" href="classCVarArray.html">VAR_ARRAY</a>&amp; y, <a class="code" href="classCVarArray.html">VAR_ARRAY</a>&amp; z)</div><div class="line">{</div><div class="line">    <span class="keywordtype">char</span> fileName[128];</div><div class="line">    <a class="code" href="Problem_8h.html#ad29970b63c4c384443d2fe43238d28e1">getprobname</a>(fileName);</div><div class="line">    strcat(fileName,<span class="stringliteral">&quot;.sol&quot;</span>);</div><div class="line">    std::ofstream fout(fileName);</div><div class="line">    <span class="keywordflow">if</span> (!fout.is_open()) {</div><div class="line">        <span class="keywordflow">throw</span> <span class="keyword">new</span> <a class="codeRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCFileException.html">CFileException</a>(<span class="stringliteral">&quot;Cbatch::ptintSol&quot;</span>,fileName);</div><div class="line">    }</div><div class="line">    </div><div class="line">    <a class="code" href="classCIndex.html">INDEX</a> state, tsk, unit;</div><div class="line">    <span class="keywordtype">int</span> t;</div><div class="line">    </div><div class="line">    fout &lt;&lt; <span class="stringliteral">&quot;Objective = &quot;</span> &lt;&lt; <a class="code" href="Problem_8h.html#af8f182c1d6a1a89fb9f4c3d68bba3b3e">getobj</a>() &lt;&lt; <span class="stringliteral">&quot;\nStock: &quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (STATES.initIt(); STATES.getNext(state);)</div><div class="line">        fout &lt;&lt; <a class="code" href="Problem_8h.html#a029fa4f1fc382f0ddc992f769969cd0f">getval</a>(z(state,H)) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line">    fout &lt;&lt; <span class="stringliteral">&quot;\nSchedule:\n&quot;</span>;</div><div class="line">    <span class="keywordflow">for</span> (UNITS.initIt(); UNITS.getNext(unit);) {</div><div class="line">        fout &lt;&lt; unit &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div><div class="line">        <span class="keywordflow">for</span> (t=0; t &lt; H; ++t)</div><div class="line">            <span class="keywordflow">for</span> (TASKS.initIt(); TASKS.getNext(tsk);)</div><div class="line">                <span class="keywordflow">if</span> (<a class="code" href="Problem_8h.html#a029fa4f1fc382f0ddc992f769969cd0f">getval</a>(y(tsk,unit,t)) &gt; 1.0e-7)</div><div class="line">            fout &lt;&lt; <span class="stringliteral">&quot;batch of task &quot;</span> &lt;&lt; tsk</div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;: starts at &quot;</span> &lt;&lt; t </div><div class="line">                 &lt;&lt; <span class="stringliteral">&quot;, size = &quot;</span> &lt;&lt; <a class="code" href="Problem_8h.html#a029fa4f1fc382f0ddc992f769969cd0f">getval</a>(y(tsk,unit,t)) &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    fout.close();</div><div class="line">} <span class="comment">// end of Cbatch::printSolution</span></div></div><!-- fragment --></p>
<p>You can find a bach scheduling application based on <code>Cbatch</code> in <code>$MIPCLDIR/examples/mipshell/batch</code>. If we run that program to schedule our example process, we get the schedule given below.</p>
<p>### Schedule for example process </p><div class="fragment"><div class="line">Objective = 2717.03</div><div class="line">Stock: 864 898 865.25 0 89.375 0 0 136 147.375</div><div class="line">Schedule:</div><div class="line">unit 0:</div><div class="line">batch of task 0: start at 1, size = 52</div><div class="line">batch of task 0: start at 3, size = 32</div><div class="line">batch of task 0: start at 7, size = 52</div><div class="line">unit 1:</div><div class="line">batch of task 1: start at 0, size = 80</div><div class="line">batch of task 2: start at 2, size = 80</div><div class="line">batch of task 2: start at 4, size = 80</div><div class="line">batch of task 1: start at 6, size = 78</div><div class="line">batch of task 2: start at 8, size = 80</div><div class="line">unit 2:</div><div class="line">batch of task 1: start at 0, size = 46</div><div class="line">batch of task 2: start at 2, size = 50</div><div class="line">batch of task 3: start at 4, size = 50</div><div class="line">batch of task 3: start at 5, size = 13.75</div><div class="line">batch of task 3: start at 6, size = 50</div><div class="line">batch of task 3: start at 7, size = 50</div><div class="line">batch of task 2: start at 8, size = 50</div><div class="line">unit 3:</div><div class="line">batch of task 4: start at 5, size = 50</div><div class="line">batch of task 4: start at 8, size = 113.75</div></div><!-- fragment --><p>We see that the maximum profit is 2717.025 units corresponding to the production of 136.0kg of Product 1 and 147.375kg of Product 2, with a residual amount of 89.375kg of intermediate AB. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
