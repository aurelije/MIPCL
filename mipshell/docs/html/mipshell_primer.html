<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MIPschell: MIPschell Primer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MIPschell
   &#160;<span id="projectnumber">1.3.0</span>
   </div>
   <div id="projectbrief">A language for writing Mixed Integer Programs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">MIPschell Primer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="mipshell_probDef"></a>
Problem Definition</h1>
<p>In <b>MIPshell</b> any optimization problem is represented as an instance of the base class <code><a class="el" href="classCProblem.html" title="CProblem represents MIP instances. ">CProblem</a></code>. We create a problem by providing to the constructor a problem name. Then we use functions of the base classes <code><a class="el" href="classCProblem.html" title="CProblem represents MIP instances. ">CProblem</a></code>, <code><a class="elRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCMIP.html">CMIP</a></code>, and <code><a class="elRef" doxygen="/home/nick/programs/mip/mipcl/docs/mipcl.tag:../../../mipcl/docs/html/" href="../../../mipcl/docs/html/classCLP.html">CLP</a></code>. Usually a <b>MIPshell</b> program starts with two statements similar to the following ones:</p>
<div class="fragment"><div class="line">`<a class="code" href="classCProblem.html">CProblem</a>` `prob(<span class="stringliteral">&quot;name&quot;</span>)`;</div><div class="line">prob.`model()`;</div></div><!-- fragment --><h1><a class="anchor" id="mipshell_sets"></a>
Sets And Indices</h1>
<p>In <b>MIPshell</b> we use <em>sets of integers</em> (<code>INT_SET</code>), <em>reals</em> (<code>REAL_SET</code>), and <em>indices</em> (<code>INDEX_SET</code>).</p>
<p><em>Indices</em> are objects of type <code><a class="el" href="classCIndex.html">CIndex</a></code> (<code>INDEX</code> is an alias for <code><a class="el" href="classCIndex.html">CIndex</a></code>). Any object of type <code><a class="el" href="classCIndex.html">CIndex</a></code> represents an index as a string of up to <code>63</code> characters. The next example code demonstrate the most commonly used operations with indices:</p>
<div class="fragment"><div class="line"><a class="code" href="classCIndex.html">INDEX</a> i1(1,2,3), i2(<span class="stringliteral">&quot;Prod4&quot;</span>,5), i[2];</div><div class="line">cout &lt;&lt; i1 + i2 &lt;&lt; endl;</div><div class="line"><span class="keywordflow">if</span> (i1.include(3)) {</div><div class="line">     i1.<a class="code" href="classCIndex.html#ace7ab16d02cf10630bf5a2db8ec9f2cd">split</a>(2,i);</div><div class="line">     out &lt;&lt; i[0] &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; i[1] &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>First, we create two indices <code>i1</code>, <code>i2</code>, and an array of indices, <code>i</code>, of size two. Furthermore, <code>i1</code> and <code>i2</code> are initialized to store, respectively, the strings "1,2,3" and "Prod4,5". By definition, <code>i1+i2</code> is an index that stores the string "1,2,3,Prod4,5", which is printed to the standard output stream. Each nonempty index-string consists of indices separated by commas. The last three lines of the above code do the following. If "3" is a subindex of <code>i1</code> (which is true), <code>i1</code> is split into subindices "1", "2", "3", and the first two subindices are stored in the array <code>i</code>. Therefore, the last statement prints the string "1 2".</p>
<p>In the following example, we declare two sets: <code>I</code> of integers, <code>R</code> of reals, and <code>N</code> of indices:</p>
<div class="fragment"><div class="line"><a class="code" href="classCSet.html">INT_SET</a> I(<span class="stringliteral">&quot;{1,3,5,7}&quot;</span>);</div><div class="line"><a class="code" href="classCSet.html">REAL_SET</a> R;</div><div class="line"><a class="code" href="classCSet.html">INDEX_SET</a> N;</div></div><!-- fragment --><p>After creation, <code>R</code> and <code>N</code> are empty set, while <code>I</code> is initialized to the set <code>{1,3,5,7}</code>. We add new items to existing sets using the <code>add()</code> statements:</p>
<div class="fragment"><div class="line">I.add(5); R.<a class="code" href="classCSet.html#af477660b026e47d6398e52daa73f98a7">add</a>(3.14); N.<a class="code" href="classCSet.html#af477660b026e47d6398e52daa73f98a7">add</a>(<span class="stringliteral">&quot;Prod_1&quot;</span>);</div></div><!-- fragment --><p>We may compute <em>intersection</em> (operator <code>*</code>), <em>union</em> (<code>+</code>), and <em>difference</em> (<code>-</code>) of any two sets of the same type. Mixing sets of different types is not allowed. If <code>I1</code>, <code>N1</code>, and <code>N2</code> are declared as in the example below, we can not write <code>N1=I1-N2</code>. Given a set <code>S</code>, an expression <code>e in S</code> takes value <code>true</code> if <code>e</code> is an element of <code>S</code>. Next we give some examples showing manipulations with sets:</p>
<div class="fragment"><div class="line"><a class="code" href="classCSet.html">INT_SET</a> I1, I2(<span class="stringliteral">&quot;{-3,0,1,4,6}&quot;</span>), I3(<span class="stringliteral">&quot;{1,2,5,6,9}&quot;</span>);</div><div class="line"><a class="code" href="classCSet.html">INDEX_SET</a> N1, N2(<span class="stringliteral">&quot;Paris,Berlin,Minsk&quot;</span>), N3(<span class="stringliteral">&quot;London,Row&quot;</span>);</div><div class="line">I1=I2*I3; I2=<span class="stringliteral">&quot;{1,6}&quot;</span>;</div><div class="line">I1+=<span class="stringliteral">&quot;{0,3}&quot;</span>; I3=<span class="stringliteral">&quot;{0,1,3,6}&quot;</span>;</div><div class="line">N1=N2+N3; N3={Paris,Berlin,Minsk,London,Rom};</div></div><!-- fragment --><p>Input/output operations with sets are presented in the next section.</p>
<h1><a class="anchor" id="mipshell_arraysAndVectors"></a>
Arrays And Vectors</h1>
<p>In <b>MIPshell</b> dense arrays are called <em>vectors</em>, while sparse arrays (with many zero/empty entries which are not stored) are simply called <em>arrays</em>.</p>
<h2><a class="anchor" id="mipshell_vectors"></a>
Vectors</h2>
<p>Two types of <b>MIPschell</b> <em>vectors</em>, <code>INT_VECTOR</code> (vector of integers) and <code>REAL_VECTOR</code> (vector of reals), are specializations of a single template class <code><a class="el" href="classCVector.html">CVector</a></code> having the constructor:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tell&gt; <a class="code" href="classCVector.html#a6951389099c388fcd21aaf41e1188e39">CVector&lt;Tell&gt;::CVector</a>(<span class="keywordtype">int</span> size0, <span class="keywordtype">int</span> size1=0,</div><div class="line">     <span class="keywordtype">int</span> size2=0, <span class="keywordtype">int</span> size3=0);</div></div><!-- fragment --><p>Then <code>INT_VECTOR</code> and <code>REAL_VECTOR</code> are defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCVector.html">CVector&lt;int&gt;</a> <a class="code" href="mipshell_8h.html#ad4cd71ad50b34fef09425d166e05b68a">INT_VECTOR</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCVector.html">CVector&lt;double&gt;</a> <a class="code" href="mipshell_8h.html#a6fa6dc4e1aa3eb425990e23ef1a2943f">REAL_VECTOR</a>;</div></div><!-- fragment --><p>Thus, we declare a two-dimensional vector of integers of size 4x5 as follows</p>
<div class="fragment"><div class="line">INT_VECTOR A(4,5);</div></div><!-- fragment --><p>Vector indices are always integers. Furthermore, vectors are indexed from zero! It is importance to note that <b>MIPschell</b> does not perform range checking on vector indices.</p>
<h2><a class="anchor" id="mipshell_arrays"></a>
MIPshell Arrays</h2>
<p>Six types of <b>MIPschell</b> arrays are:</p>
<ul>
<li>INT_ARRAY: array of integers;</li>
<li>REAL_ARRAY: array of reals;</li>
<li>INDEX_ARRAY: array of indices;</li>
<li>INT_SET_ARRAY: array of sets of integers;</li>
<li>REAL_SET_ARRAY: array of sets of reals;</li>
<li>INDEX_SET_ARRAY: array of sets of indices.</li>
</ul>
<p>The above <b>MIPschell</b> arrays are specializations of a single template class <code><a class="el" href="classCArray.html">CArray</a></code>: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCArray.html">CArray&lt;int&gt;</a> <a class="code" href="mipshell_8h.html#a95b696d0fce6ef82857c2a723620b43d">INT_ARRAY</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCArray.html">CArray&lt;double&gt;</a> <a class="code" href="mipshell_8h.html#a5c6e6c9a699e808ec5e4f114c87b84fb">REAL_ARRAY</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCArray.html">CArray&lt;CIndex&gt;</a> <a class="code" href="mipshell_8h.html#a6d99097997ccc512378c77ecc0d0c190">INDEX_ARRAY</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCArray.html">CArray&lt;CSet&lt;int&gt;</a> <a class="code" href="mipshell_8h.html#a23f338fbe669efdb2b04968aee075393">INT_SET_ARRAY</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCArray.html">CArray&lt;CSet&lt;double&gt;</a> <a class="code" href="mipshell_8h.html#aebd08d3d1e9f35f16cf20bb9f22a00c1">REAL_SET_ARRAY</a>;</div><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCArray.html">CArray&lt;CSet&lt;CIndex&gt;</a> <a class="code" href="mipshell_8h.html#a7119589c05568bd4d3e990c7e2ca2bac">INDEX_SET_ARRAY</a>;</div></div><!-- fragment --><p>The maximum dimension of an array is 4!</p>
<p>Let us remember that <b>MIPschell</b> arrays are used to represent sparse arrays with many zero (or empty) elements which are not stored in the computer memory. By convention, <code>A(3,"Prod_10",8)</code> returns a reference to a constant zero (or empty) element if an entry indexed by <code>(3,Prod_10,8)</code> has not been previously added to <code>A</code>. For this reason, we cannot assign values to array entries and instead have to use the <code>add()</code> statements. In the following fragment we declare an array of reals, add a number of entries, and then print some array values.</p>
<div class="fragment"><div class="line">REAL_ARRAY R;</div><div class="line">A(1).<a class="code" href="classCSet.html#af477660b026e47d6398e52daa73f98a7">add</a>(5.3);</div><div class="line">A(2,<span class="stringliteral">&quot;unit_4&quot;</span>).add(-1.1);</div><div class="line">A(0,1,<span class="stringliteral">&quot;x&quot;</span>).add(7.25);</div><div class="line">cout &lt;&lt; A(2,<span class="stringliteral">&quot;unit_4&quot;</span>) &lt;&lt; endl; <span class="comment">// prints -1.1</span></div><div class="line">cout &lt;&lt; A(1,1) &lt;&lt; endl; <span class="comment">// prints 0</span></div></div><!-- fragment --><p>When modeling with <b>MIPschell</b>, we can use any <b>C++</b> structures, including arrays, which are one-dimensional (excluding static arrays). Representing multi-dimensional arrays by one-dimensional ones may obscure a model with unnecessary details. Therefore, we recommend using multi-dimensional <b>MIPschell</b> vectors and arrays. Besides, using <b>MIPschell</b> vectors and arrays is more safe since in this case allocating and freeing memory is done by <b>MIPschell</b>.</p>
<h2><a class="anchor" id="mipshell_inputOutput"></a>
Input/Output operations</h2>
<p>The next example program illustrates input/output operations with vectors, arrays, and sets.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mipshell_8h.html">mipshell.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">     REAL_VECTOR A;</div><div class="line">     <a class="code" href="classCSet.html">INT_SET</a> S;</div><div class="line">     REAL_ARRAY R;</div><div class="line">     cout &lt;&lt; <span class="stringliteral">&quot;Enter a real vector: &quot;</span>;</div><div class="line">     cin &gt;&gt; A;</div><div class="line">     cout &lt;&lt; <span class="stringliteral">&quot;Enter a set of integers: &quot;</span>;</div><div class="line">     cin &gt;&gt; S; S-=<span class="stringliteral">&quot;{2}&quot;</span>;</div><div class="line">     cout &lt;&lt; <span class="stringliteral">&quot;Enter an array of reals: &quot;</span>;</div><div class="line">     cin &gt;&gt; R;</div><div class="line">     cout &lt;&lt; A &lt;&lt; endl;</div><div class="line">     cout &lt;&lt; S &lt;&lt; endl;</div><div class="line">     cout &lt;&lt; R &lt;&lt; endl;</div><div class="line">}</div></div><!-- fragment --><p>When we compile and run this program, if we type in first </p><pre class="fragment">$ dim(2,2): [[2,1.5],[3.1,4]]
</pre><p>then </p><pre class="fragment">$ {1,2,3,5,7}
</pre><p>and then </p><pre class="fragment">$ {(0,3) =&gt;3.14; (1,2) =&gt; 2.0; (3,1) =&gt; -1.1}
</pre><p>as input, the output is </p><pre class="fragment">$ dim(2,2):
$     [[2,1.5],
$     [3.1,4]]
$ {1,3,5,7}
$ {(0,3) =&gt;3.14; (1,2) =&gt; 2.0; (3,1) =&gt; -1.1}
</pre><h1><a class="anchor" id="mipshell_variables"></a>
Variables</h1>
<p>In <b>MIPshell</b>, variables are instances of the <code><a class="el" href="classCVar.html">CVar</a></code> class. The most commonly used constructor of <code><a class="el" href="classCVar.html">CVar</a></code> is defined as</p>
<div class="fragment"><div class="line"><a class="code" href="classCVar.html">CVar</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> type=<a class="code" href="Var_8h.html#a1cec2e482ee71e7e701a8ef2025f8ebaa3e58089cdeaafd3168fd5c68f146ef81">REAL_GE</a>);</div></div><!-- fragment --><p>The first argument is the variable <em>name</em> of length up to 63 characters. The names are used when a solution is printed. The second argument defines the <em>type</em> and, for integer and binary variable, the <em>priority</em> of the variable. The type of a variable defines the <em>feasible domain</em> of this variables. and are of one of the following types:</p>
<table class="doxtable">
<tr>
<th align="right">Type </th><th align="left">Feasible values  </th></tr>
<tr>
<td align="right">REAL </td><td align="left">real numbers </td></tr>
<tr>
<td align="right">REAL_GE </td><td align="left">non-negative reals </td></tr>
<tr>
<td align="right">REAL_LE </td><td align="left">non-positive reals </td></tr>
<tr>
<td align="right">INT </td><td align="left">integer numbers </td></tr>
<tr>
<td align="right">INT_GE </td><td align="left">non-negative integers </td></tr>
<tr>
<td align="right">INT_LE </td><td align="left">non-positive integers </td></tr>
<tr>
<td align="right">BIN </td><td align="left">0 or 1 </td></tr>
</table>
<p>Variables of types <code>REAL</code>, <code>REAL_GE</code>, and <code>REAL_LE</code> are called <em>real</em> or <em>continuous</em>. Variables of types <code>INT</code>, <code>INT_GE</code>, and <code>INT_LE</code> are <em>integer variables</em>. A <em>binary variable</em> of type <code>BIN</code> is also an integer variable.</p>
<p>The <em>priority</em> of an integer variable is a non-negative integer (of length at most 16 bit) that is used when a integer variable with fractional value is selected for branching; the higher priority the higher probability for variable to be selected. The <em>composed type</em> of a variable is the sum of its type and priority. For example, we declare a nonnegative integer variable <code>x</code> named <code>X</code> and having priority of 2 as follows:</p>
<div class="fragment"><div class="line"><a class="code" href="classCVar.html">VAR</a> x(<span class="stringliteral">&quot;X&quot;</span>,<a class="code" href="Var_8h.html#a1cec2e482ee71e7e701a8ef2025f8ebaa9700b305a3d7a8829567b7ebc37ce1e8">INT_GE</a>+2);</div></div><!-- fragment --><p>Here we used an alias <code>VAR</code> for <code><a class="el" href="classCVar.html">CVar</a></code> defined by</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classCVar.html">CVar</a> <a class="code" href="mipshell_8h.html#aea92a2795d5f60bf19310842eaf0da7c">VAR</a>;</div></div><!-- fragment --><h2><a class="anchor" id="mipshell_arraysOfVariables"></a>
Arrays Of Variables</h2>
<p><b>MIPschell</b> provides a specific class, <code><a class="el" href="classCVarVector.html">CVarVector</a></code>, for representing <em>multidimensional</em> vectors of variables. Normally we define a <em>vector of variables</em> using the constructor</p>
<div class="fragment"><div class="line"><a class="code" href="classCVarVector.html">CVarVector</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> type, <span class="keywordtype">int</span> size0,</div><div class="line">          <span class="keywordtype">int</span> size1=0, <span class="keywordtype">int</span> size2=0, <span class="keywordtype">int</span> size3=0);</div></div><!-- fragment --><p>The meaning of the first two parameters is the same as for the constructor of <code><a class="el" href="classCVar.html">CVar</a></code>, the last four parameters define the size of the vector. In <b>MIPschell</b> in place of <code><a class="el" href="classCVarVector.html">CVarVector</a></code> we can also use the alias name <code>VAR_VECTOR</code>. For instance, the declaration</p>
<div class="fragment"><div class="line"><a class="code" href="classCVarVector.html">VAR_VECTOR</a> x(<span class="stringliteral">&quot;X&quot;</span>,<a class="code" href="Var_8h.html#a1cec2e482ee71e7e701a8ef2025f8ebaa3dba92f17ebb0d7efe6056d51e9acdc7">BIN</a>+8},5,4);</div></div><!-- fragment --><p>means that <code>x</code> is a (5x4)-vector of binary variables <code>x(i,j)</code> each of priority~8, the variable <code>x(i,j)</code> is named by <code>X(i,j)</code>. Let us remember that variable names are strings of up to 63 character. Because of this restriction, if the full name (name itself plus indices) of a vector member has more then 63 characters, the tail string starting from character 64 is truncated.</p>
<p>Vectors of variables in <b>MIPschell</b> are indexed from zero!</p>
<p>In <b>MIPschell</b> for indexing variables, we can also use sets of indices or integers. To declare an <em>array of variables</em>, we use one of the constructors:</p>
<div class="fragment"><div class="line"><a class="code" href="classCVarArray.html">CVarArray</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> type, <a class="code" href="classCBasicSet.html">CBasicSet</a>&amp; s0);</div><div class="line"><a class="code" href="classCVarArray.html">CVarArray</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> type, <a class="code" href="classCBasicSet.html">CBasicSet</a>&amp; s0, <a class="code" href="classCBasicSet.html">CBasicSet</a>&amp; s1);</div><div class="line"><a class="code" href="classCVarArray.html">CVarArray</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> type, <a class="code" href="classCBasicSet.html">CBasicSet</a>&amp; s0, <a class="code" href="classCBasicSet.html">CBasicSet</a>&amp; s1, <a class="code" href="classCBasicSet.html">CBasicSet</a>&amp; s2);</div><div class="line"><a class="code" href="classCVarArray.html">CVarArray</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> type, <a class="code" href="classCBasicSet.html">CBasicSet</a>&amp; s0,</div><div class="line">          <a class="code" href="classCBasicSet.html">CBasicSet</a>&amp; s1, <a class="code" href="classCBasicSet.html">CBasicSet</a>&amp; s2}, <a class="code" href="classCBasicSet.html">CBasicSet</a>}\&amp; s3}).</div></div><!-- fragment --><p>The maximum dimension of an array of variables is 4. The first two parameters are identical to those in the constructor of <code><a class="el" href="classCVar.html">CVar</a></code>. The <code><a class="el" href="classCBasicSet.html">CBasicSet</a></code> class is the virtual base class for the <code><a class="el" href="classCSet.html">CSet</a></code> classes. Therefore, the <code>INT_SET</code> and <code>INDEX_SET</code> objects can be used when declaring variable arrays. For example, the following declarations are legal in <b>MIPschell</b>:</p>
<div class="fragment"><div class="line"><a class="code" href="classCSet.html">INT_SET</a> I(<span class="stringliteral">&quot;{1,3,5,7}&quot;</span>);</div><div class="line"><a class="code" href="classCSet.html">INDEX_SET</a> Prod(<span class="stringliteral">&quot;{Gasoline,Oil,JetFuel}&quot;</span>);</div><div class="line"><a class="code" href="classCVarArray.html">VAR_ARRAY</a> x(<span class="stringliteral">&quot;X&quot;</span>,<a class="code" href="Var_8h.html#a1cec2e482ee71e7e701a8ef2025f8ebaa3dba92f17ebb0d7efe6056d51e9acdc7">BIN</a>,I,Prod);</div></div><!-- fragment --><p>When a vector or array of variables is created, all its elements (variables) are of the same type, and have the same domain. We can change the type of a particular variable, say <code>x(0,0)</code>, by calling either</p>
<div class="fragment"><div class="line">x(0,0).setType(<a class="code" href="Var_8h.html#a1cec2e482ee71e7e701a8ef2025f8ebaa9700b305a3d7a8829567b7ebc37ce1e8">INT_GE</a>);</div></div><!-- fragment --><p>or</p>
<div class="fragment"><div class="line">settype(x(0,0),<a class="code" href="Var_8h.html#a1cec2e482ee71e7e701a8ef2025f8ebaa9700b305a3d7a8829567b7ebc37ce1e8">INT_GE</a>);</div></div><!-- fragment --><h1><a class="anchor" id="mipshell_constraints"></a>
Constraints</h1>
<p>In <b>MIPschell</b> constraints are instances of the <code><a class="el" href="classCCtr.html">CCtr</a></code> class. Usually, we do not declare objects of type <code><a class="el" href="classCCtr.html">CCtr</a></code>. We simply write down constraints and leave the rest to <b>MIPschell</b>. Two examples of valid <b>MIPschell</b> constraints are</p>
<div class="fragment"><div class="line">0 &lt;= x(i,2) - 4.5*z + 2*y(4) &lt;= 5;</div><div class="line">sum(i in S: i &lt; j) a(i,j)*x(i,j) == b(i);</div></div><!-- fragment --><p>The <code>sum</code> operator is discussed in <a class="el" href="mipshell_primer.html#mipshell_functionsAndOperators">MIPshell Functions And Operators</a>. Here it is enough to say that the latter <b>MIPschell</b> constraint in the mathematical notation is written as follows:</p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \sum_{i\in S,\: i &lt; j } a(i,j)\cdot x(i,j) = b(i). \]" src="form_0.png"/>
</p>
<p>Each <b>MIPschell</b> constraint is translated into one MIPCL constraint. Therefore, two-sided constraints like the following one are not allowed:</p>
<div class="fragment"><div class="line">x1 &lt;= x2 - x3  &lt;= x4 + 5;</div></div><!-- fragment --><p>Here <code>x1</code>, <code>x2</code>, <code>x3</code>, and <code>x4</code> are <b>MIPschell</b> variables. This constraint should be rewritten, for example, as follows:</p>
<div class="fragment"><div class="line">x1 &lt;= x2 - x3;</div><div class="line">x2 - x3 &lt;= x4 + 5;</div></div><!-- fragment --><p>When we are solving an LP and are interested in having an optimal dual solution, in particular, shadow prices for constraints, we need to assign names to the constraints. The following examples show how it can be done:</p>
<div class="fragment"><div class="line">(x - 2*y &lt;= z).setName}(<span class="stringliteral">&quot;name&quot;</span>);</div><div class="line">(sum(<span class="keywordtype">int</span> i in [0,n)) x(i,j) == 1).setName(<span class="stringliteral">&quot;assign&quot;</span>,j);</div></div><!-- fragment --><p>In the latter example the constraint is given the name "assign(j)", where the value of <code>j</code> must be an integer. When naming constraints, we can use up to three indices. The maximum total name length (with all indices) is 31. Be careful, statements like the following one</p>
<div class="fragment"><div class="line">(x &lt;= 1.0).setName(<span class="stringliteral">&quot;name&quot;</span>);</div></div><!-- fragment --><p>are not correct. This is because the above statement is used to change the upper bound of variable <code>x</code>, and <b>MIPschell</b> does not create any constraint. Thus, there is no object to assign the name.</p>
<h2><a class="anchor" id="mipshell_discreteVariables"></a>
Discrete Variables</h2>
<p>A <em>discrete variable</em> is a real variable restricted to take values from a given set of reals. We declare discrete variables in one of the two following ways:</p>
<div class="fragment"><div class="line">x in <span class="stringliteral">&quot;{2,5,9}&quot;</span>;</div><div class="line">y in S;</div></div><!-- fragment --><p>Here <code>S</code> is a set of reals (of type <code>REAL_SET</code>). Be careful, in the latter case any changes applied to <code>S</code> until the problem is loaded (by calling the function <code>load()</code>) will also affect the domain of <code>y</code>.</p>
<h2><a class="anchor" id="mipshell_piecewiseFunctions"></a>
Piecewise-Linear Functions and Curves</h2>
<p>Let a real variable <code>y</code> be a function of another real variable <code>x</code>. We may approximate this function by a piecewise-linear function and represent the latter in <b>MIPschell</b> as follows:</p>
<div class="fragment"><div class="line">y == <span class="keyword">function</span>(x,<span class="stringliteral">&quot;(0,0),(1,1),(2.4),(3,9),(4,16),(5,25)&quot;</span>);</div><div class="line">u == <span class="keyword">function</span>(v,A);</div></div><!-- fragment --><p>In the first example <img class="formulaInl" alt="$y\approx x^2$" src="form_1.png"/> on the interval [0,5], in the second <code>A</code> is a real (of type <code>REAL_VECTOR</code>) vector of size <code>k x 2</code>, <code>u</code> is a piecewise-linear function of <code>v</code>, and</p>
<div class="fragment"><div class="line">(A(0,0),A(0,1)),...,(A(k,0),A(k,1))</div></div><!-- fragment --><p>are its breakpoints.</p>
<p>Similarly, we may define a set of points $(x,y)$ lying on a piecewise-linear curve:</p>
<div class="fragment"><div class="line">curve(x1,y1,<span class="stringliteral">&quot;(0,0),(1,1),(2.4),(3,9),(4,16),(5,25)&quot;</span>);</div><div class="line">curve(x2,y2,A);</div></div><!-- fragment --><p>The difference between two constructs, <code>function</code> and <code>curve</code>, is in that the pairs of points in the declaration of a <code>function</code> must be listed in the increasing order of the <code>x</code>-values.</p>
<h1><a class="anchor" id="mipshell_functionsAndOperators"></a>
MIPshell Functions And Operators</h1>
<p>Most of the <b>MIPschell</b> functionality is due to operator overloading. Besides, there are a few functions and operators that are briefly discussed in this section:</p>
<ul>
<li><code>void load()</code>: loads the problem (builds the matrix, does preprocessing, performs scaling, and etc.);</li>
<li><code>void solve()</code>: solves the problem (the problem must be previously loaded);</li>
<li><code>void optimize()</code>: loads and solves the problem (<code>load()</code> + <code>solve()</code>).</li>
<li><code>void printsol(const char *fileName=0)</code>: prints the solution to the file which name is given by the string <code>fileName</code>; if <code>fileName=0</code>, then the output file name is the problem name appended with the extension ".sol";</li>
<li><code>double <a class="el" href="Problem_8h.html#af8f182c1d6a1a89fb9f4c3d68bba3b3e" title="alias for CProblem::getObjective() ">getobj()</a></code>: returns the objective value of the optimal solution;</li>
<li><code>double <a class="el" href="Problem_8h.html#a029fa4f1fc382f0ddc992f769969cd0f" title="alias for CProblem::getValue() ">getval(CVar&amp; var)</a></code>: returns the value of variable <code>var</code>.</li>
<li><code>double <a class="el" href="Problem_8h.html#ae08406ec7747b7bf876886b233a2767b" title="alias for CProblem::getReducedCost() ">getredcost(CVar&amp; var)</a></code>: returns the reduced cost of the variable <code>var</code> (only for LPs);</li>
<li><code>double <a class="el" href="Problem_8h.html#ac629c9f96915f781578b35273dc61447" title="alias for CProblem::getShadowPrice() ">getprice(CCtr&amp; ctr)</a></code>: returns the shadow price of the constraint <code>ctr</code> (only for LPs).</li>
<li><code>void <a class="el" href="Problem_8h.html#a519b31597e2dfd997c765bd173d3c08b" title="alias for CLP::preprocOff() ">preprocoff()</a></code>: switches off preprocessing; normally, preprocessing is switched off when a dual optimal solution is needed;</li>
<li><code>void setcutdepth(int depth)</code>: cuts will be generated for nodes of depth less than <code>deph</code>. If <code>depth=0</code>, cuts will be generated only for the root LP; to switch off generating cuts, call <code>setcutdepth()</code> with <code>depth</code> set to $-1$;</li>
<li><code>void settype(CVar&amp; var, VARTYPE type)</code>: sets the type of the variable <code>var</code> to the value of <code>type</code>.</li>
</ul>
<p>The <code>forall</code> and <code>sum</code> operators are inherent to practically any optimization modelling language. In <b>MIPschell</b> these operators are of the form</p>
<div class="fragment"><div class="line">forall(i1 in S1,...,ik in Sk: condition) <span class="keyword">operator</span>,</div><div class="line">sum(i1 in S1,...,ik in Sk: condition) linear expression,</div></div><!-- fragment --><p>where <code>i1,...,ik</code> are integers, <code>S1,...,Sk</code> are sets of integers, and <em>operator</em> is any <b>C++</b> operator, including the new <b>MIPschell</b> operators. A <em>linear expression</em> is a multiplicative expresion that is linear with respect to <b>MIPschell</b> variables.</p>
<p>In the next code fragment both operators, <code>forall, and</code>sum`, are used:</p>
<div class="fragment"><div class="line">forall(<span class="keywordtype">int</span> i in [0,m)) {</div><div class="line">     sum(<span class="keywordtype">int</span> j in} [0,n)) a(i,j)*x(i,j) == 1;</div><div class="line">     x(i,j) &lt;= b(i);</div><div class="line">}</div></div><!-- fragment --><p>For integers <code>k</code> and <code>l</code>, <code>[k,l)</code> (resp. <code>[k,l]</code>) denotes the set <code>{k,...,l-1}</code> (resp. <code>{k,...,l}</code>).</p>
<p>Besides those mentioned above, there are also a few functions which are used when developing applications with user defined cuts. Those functions are considered in <a class="el" href="portfolio.html#mipshell_optPortfolio">Portfolio Optimization (Markovitz's Model)</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
